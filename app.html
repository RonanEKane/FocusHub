<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- SECURITY: Force HTTPS -->
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    <title>FocusHub - Built for Brains That Wander, but Still Want to Win</title>
    <!-- SEO & Social Meta Tags (V20.4) -->
    <meta name="description" content="FocusHub - Built for Brains That Wander, but Still Want to Win. Complete productivity system for ADHD with tough-love accountability.">
    <meta name="keywords" content="ADHD, productivity, focus, task management, sprint timer, accountability">
    <meta name="author" content="FocusHub">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="FocusHub - Productivity for ADHD Brains">
    <meta property="og:description" content="Built for Brains That Wander, but Still Want to Win">
    <meta property="og:image" content="/FocusHub_horiinv.svg">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:title" content="FocusHub - Productivity for ADHD Brains">
    <meta property="twitter:description" content="Built for Brains That Wander, but Still Want to Win">
    <meta property="twitter:image" content="/FocusHub_horiinv.svg">
    
    <!-- Google Analytics (V20.5) -->
    <!-- ‚ö†Ô∏è ACTION REQUIRED: Get your tracking ID from analytics.google.com -->
    <!-- <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-XXXXXXXXXX');
    </script> -->
    
    <link rel="preload" href="style.css?v=20.4" as="style">
    <link rel="stylesheet" href="style.css?v=20.4">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="reflections-expanded.js"></script>
    <script src="keyboard-shortcuts.js"></script>
</head>
<body class="preload">
    <!-- Onboarding Modal (V20.5) -->
    <div id="onboardingModal" class="onboarding-modal" style="display: none;">
        <div class="onboarding-content">
            <!-- Step 1: Welcome -->
            <div class="onboarding-step" id="onboard-step-1">
                <h1 style="font-size: 2.5rem; margin-bottom: 1rem; color: var(--accent-primary);">
                    Welcome to FocusHub
                </h1>
                <p style="font-size: 1.25rem; margin-bottom: 2rem; color: var(--text-secondary);">
                    Built for brains that wander. Let's get you set up in 60 seconds.
                </p>
                <button class="btn-primary" onclick="showOnboardingStep(2)" style="padding: 1rem 3rem; font-size: 1.25rem;">
                    Let's Go ‚Üí
                </button>
            </div>

            <!-- Step 2: Three Buckets -->
            <div class="onboarding-step" id="onboard-step-2" style="display: none;">
                <h2 style="font-size: 2rem; margin-bottom: 1rem; color: var(--accent-primary);">
                    The Three-Bucket System
                </h2>
                <p style="margin-bottom: 2rem;">
                    FocusHub uses only 3 task buckets. That's it. No folders, no tags, no endless organization.
                </p>
                
                <div style="display: grid; gap: 1.5rem; margin-bottom: 2rem;">
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid var(--accent-primary);">
                        <h3 style="color: var(--accent-primary); margin-bottom: 0.5rem;">üìã ADMIN</h3>
                        <p style="color: var(--text-secondary);">Quick tasks. Emails. Scheduling. Things that take 1-2 sprints.</p>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid #ef4444;">
                        <h3 style="color: #ef4444; margin-bottom: 0.5rem;">üéØ DEEP WORK</h3>
                        <p style="color: var(--text-secondary);">Hard stuff. Writing. Coding. Design. Requires focus. 3-5 sprints.</p>
                    </div>
                    
                    <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; border-left: 4px solid #10b981;">
                        <h3 style="color: #10b981; margin-bottom: 0.5rem;">‚ö° STRATEGIC</h3>
                        <p style="color: var(--text-secondary);">Important long-term work. Planning. Big decisions. 2-4 sprints.</p>
                    </div>
                </div>
                
                <button class="btn-primary" onclick="showOnboardingStep(3)" style="padding: 1rem 3rem;">
                    Got It ‚Üí
                </button>
            </div>

            <!-- Step 3: Sprint System -->
            <div class="onboarding-step" id="onboard-step-3" style="display: none;">
                <h2 style="font-size: 2rem; margin-bottom: 1rem; color: var(--accent-primary);">
                    Sprint-Based Work
                </h2>
                <p style="margin-bottom: 1.5rem;">
                    Instead of endless to-do lists, you work in <strong>sprints</strong>.
                </p>
                
                <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem;">
                    <h3 style="margin-bottom: 1rem;">Here's how it works:</h3>
                    <ol style="margin-left: 1.5rem; line-height: 2;">
                        <li>Choose your energy level (Low = 15min, Medium = 20min, High = 30min)</li>
                        <li>Hit START FOCUS</li>
                        <li>Work until the timer ends</li>
                        <li>Take a break or start the next sprint</li>
                    </ol>
                </div>
                
                <p style="margin-bottom: 2rem; color: var(--text-secondary);">
                    Each task shows how many sprints it needs. The system calculates your total sprint goal for the day.
                </p>
                
                <button class="btn-primary" onclick="showOnboardingStep(4)" style="padding: 1rem 3rem;">
                    Next ‚Üí
                </button>
            </div>

            <!-- Step 4: The Agent -->
            <div class="onboarding-step" id="onboard-step-4" style="display: none;">
                <h2 style="font-size: 2rem; margin-bottom: 1rem; color: var(--accent-primary);">
                    Meet The Agent
                </h2>
                <p style="margin-bottom: 1.5rem;">
                    Your AI accountability system. Not gentle. Not mean. Just honest.
                </p>
                
                <div style="background: var(--bg-secondary); padding: 2rem; border-radius: 8px; margin-bottom: 2rem; border: 2px solid var(--accent-primary);">
                    <p style="font-style: italic; font-size: 1.125rem; margin-bottom: 1rem;">
                        "Sprint 3/8 complete. 5 sprints behind. Deficit severe. Start now."
                    </p>
                    <p style="font-size: 0.875rem; color: var(--text-secondary);">
                        ‚Äî The Agent (Tough mode)
                    </p>
                </div>
                
                <p style="margin-bottom: 2rem;">
                    The Agent adapts to your progress and calls out patterns. You can set intensity: Supportive, Balanced, or Tough.
                </p>
                
                <button class="btn-primary" onclick="finishOnboarding()" style="padding: 1rem 3rem;">
                    Start My First Day ‚Üí
                </button>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header class="app-header">
        <div class="logo-section">
            <img id="appLogo" src="FocusHub_horiinv.svg" alt="FocusHub">
        </div>
        <div class="header-timer" id="headerTimerSection" style="display: none;">
            <span id="stickyTimer" style="font-family: 'JetBrains Mono', monospace; font-size: 1.25rem; font-weight: 700; color: var(--industrial-orange);">20:00</span>
        </div>
        <div class="header-actions">
            <button class="btn" id="dashboardBtn" title="View your stats and progress">DASHBOARD</button>
            <button class="btn" id="themeToggle" title="Switch between dark and light theme">DARK</button>
            <button class="btn" id="logoutBtn" title="Sign out of FocusHub">Logout</button>
            <button class="btn btn-danger" id="endDayBtn" title="Complete your day and get your grade">END SESSION</button>
        </div>
    </header>

    <!-- Main Container -->
    <div class="app-container">
        <!-- Left Column: Main Content -->
        <main class="main-content">
            <!-- Sprint Timer Section - DOMINANT -->
            <section class="sprint-timer-section dominant">
                <div class="section-header">
                    <h2>‚è±Ô∏è FOCUS SESSION</h2>
                </div>
                
                <div class="energy-row">
                    <div class="energy-select">
                        <label>Energy Level:</label>
                        <select id="energyLevel" title="Choose sprint length based on your current energy level">
                            <option value="low">‚ö° Kinda "Meh" (15 min)</option>
                            <option value="medium" selected>‚ö°‚ö° Solid (20 min)</option>
                            <option value="high">‚ö°‚ö°‚ö° Locked In (30 min)</option>
                        </select>
                    </div>
                    <div class="meeting-toggle-container">
                        <label class="toggle-switch">
                            <input type="checkbox" id="meetingToggle">
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="meeting-label">Meeting</span>
                    </div>
                </div>

                <div class="timer-buttons">
                    <button class="timer-btn" data-duration="15">15 min</button>
                    <button class="timer-btn active" data-duration="20">20 min</button>
                    <button class="timer-btn" data-duration="30">30 min</button>
                    <button class="timer-btn timer-btn-break" data-duration="5">Start Break</button>
                </div>

                <!-- LARGE TIMER DISPLAY -->
                <div class="timer-display-large" id="timerDisplay">
                    <div class="timer-value">20:00</div>
                    <div class="timer-status">Ready to start</div>
                </div>

                <button class="btn-start-sprint" id="startSprintBtn" title="Start a focused work session">START FOCUS</button>
            </section>

            <!-- Task Command Center -->
            <section class="task-section">
                <div class="section-header">
                    <h2>‚ö° TASK COMMAND CENTER</h2>
                    <div class="header-right">
                        <div class="priority-legend">
                            <span class="legend-item"><span class="priority-dot priority-high"></span> High</span>
                            <span class="legend-item"><span class="priority-dot priority-medium"></span> Med</span>
                            <span class="legend-item"><span class="priority-dot priority-low"></span> Low</span>
                        </div>
                        <span class="sprint-target">Target: <span id="sprintTarget">5</span> sprints</span>
                    </div>
                </div>

                <div class="task-input-compact">
                    <div class="task-input-main">
                        <label class="input-label-compact">TASK INPUT:</label>
                        <textarea id="taskInput" class="task-textarea-compact" placeholder="Add tasks (one per line)"></textarea>
                    </div>
                    <button class="parse-btn-compact" id="parseBtn">ADD TO HOLDING</button>
                </div>

                <!-- Holding Area -->
                <div class="holding-area">
                    <div class="holding-header">
                        <h3>üì¶ Holding Area</h3>
                        <span class="task-count" id="holdingCount">0</span>
                    </div>
                    <div id="holdingTasks" class="task-list" data-bucket="holding">
                        <p class="empty-state">[ AWAITING_INPUT ]</p>
                    </div>
                </div>

                <!-- THREE BUCKETS -->
                <div class="buckets-grid">
                    <!-- ADMIN Bucket -->
                    <div class="bucket">
                        <div class="bucket-header">
                            <h3>üìã ADMIN</h3>
                            <span class="bucket-count" id="adminCount">0</span>
                        </div>
                        <div id="adminBucket" class="task-list" data-bucket="admin">
                            <p class="empty-state-small">[ AWAITING_INPUT ]</p>
                        </div>
                    </div>

                    <!-- DEEP WORK Bucket -->
                    <div class="bucket">
                        <div class="bucket-header">
                            <h3>üéØ DEEP WORK</h3>
                            <span class="bucket-count" id="deepworkCount">0</span>
                        </div>
                        <div id="deepworkBucket" class="task-list" data-bucket="deepwork">
                            <p class="empty-state-small">[ AWAITING_INPUT ]</p>
                        </div>
                    </div>

                    <!-- STRATEGIC Bucket -->
                    <div class="bucket">
                        <div class="bucket-header">
                            <h3>üé≤ STRATEGIC</h3>
                            <span class="bucket-count" id="strategicCount">0</span>
                        </div>
                        <div id="strategicBucket" class="task-list" data-bucket="strategic">
                            <p class="empty-state-small">[ AWAITING_INPUT ]</p>
                        </div>
                    </div>
                </div>

                <!-- TODAY'S WINS - Shows completed tasks -->
                <div class="wins-section hidden" id="winsSection">
                    <div class="wins-header">
                        <h3>üèÜ TODAY'S WINS</h3>
                        <span class="wins-count" id="winsDisplayCount">0</span>
                    </div>
                    <div id="winsList" class="wins-list">
                        <p class="empty-state">Complete a task to see it here!</p>
                    </div>
                </div>
            </section>
        </main>

        <!-- Right Column: Sidebar -->
        <aside class="sidebar">
            <!-- System Monitor - Unified Intelligence + Stats -->
            <div class="sidebar-card system-monitor">
                <div class="monitor-header">
                    <h3>SYSTEM INTELLIGENCE</h3>
                    <div class="intensity-control">
                        <span class="intensity-label">Intensity</span>
                        <div class="intensity-switch">
                            <button class="switch-btn" data-mode="supportive" title="Calmer guidance, same structure.">SUPPORTIVE</button>
                            <button class="switch-btn active" data-mode="balanced" title="Direct feedback when you drift.">BALANCED</button>
                            <button class="switch-btn" data-mode="tough" title="Blunt callouts, no softening.">TOUGH</button>
                        </div>
                    </div>
                </div>

                <div class="monitor-feed">
                    <p class="ai-text" id="aiMessage">Ready to execute. Let's go.</p>
                </div>

                <div class="monitor-telemetry">
                    <div class="t-item">
                        <span class="t-label">SPRINTS</span>
                        <span class="t-value"><span id="sprintsDone">0</span>/<span id="sprintsTotal">5</span></span>
                    </div>
                    <div class="t-item">
                        <span class="t-label">WINS</span>
                        <span class="t-value" id="winsCount">0</span>
                    </div>
                    <div class="t-item">
                        <span class="t-label">PARKED</span>
                        <span class="t-value" id="distractionsCount">0</span>
                    </div>
                </div>
            </div>

            <!-- Distraction Parking - COLLAPSED BY DEFAULT -->
            <div class="sidebar-card collapsible">
                <div class="collapsible-header" id="distractionHeader">
                    <h3>üö´ DISTRACTION PARKING</h3>
                    <span class="collapse-icon">‚ñº</span>
                </div>
                <div class="collapsible-content collapsed" id="distractionContent">
                    <div class="distraction-count-display" id="distractionCountDisplay">0</div>
                    <div class="distraction-input-col">
                        <input type="text" id="distractionInput" class="distraction-input" placeholder="Park that distraction here...">
                        <label class="checkbox-label">
                            <input type="checkbox" id="handleLaterCheck"> I'll handle this
                        </label>
                        <button class="park-btn" id="parkBtn" title="Save this distraction to deal with later">PARK IT</button>
                    </div>
                    <div id="microConfirm" class="micro-confirm hidden">Distraction parked</div>
                </div>
            </div>
        </aside>
    </div>

    <script src="supabase-config.js"></script>
    <script>
        // ============================================
        // THEME RESTORATION (MUST RUN FIRST)
        // ============================================
        (function() {
            const savedTheme = localStorage.getItem('focushub_theme');
            if (savedTheme) {
                document.documentElement.setAttribute('data-theme', savedTheme);
            }
        })();
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        const state = {
            sprintCount: 0,
            dailySprintTarget: 0,  // FIXED: Track initial target, doesn't decrease when tasks complete
            breaksCount: 0,
            distractionCount: 0,
            sessionState: 'idle',
            inMeeting: false,  // MEETING MODE: Track if user is in a meeting
            // VERSION & STUDENT MODE (Part 2)
            version: 'lite',  // 'lite', 'student', 'regular', 'premium'
            sessionMode: false,  // true for students (session-based vs clock-based)
            currentStudySession: null,  // Current study session number for students
            todayStudySessions: [],  // Array of today's study sessions
            tasks: {
                holding: [],
                admin: [],
                deepwork: [],
                strategic: [],
                wins: []
            },
            distractions: [],  // DISTRACTION TRACKING: Store parked distractions
            currentMode: 'balanced',
            energyLevel: 'medium',
            timer: {
                active: false,
                duration: 20,
                remaining: 1200,
                interval: null,
                type: 'focus',
                startTime: null,    // TIMESTAMP: When timer started
                endTime: null       // TIMESTAMP: When timer should finish
            },
            currentGrade: '-',
            lastDayStarted: null,     // DAY TRACKING
            lastActivityTime: null,   // DAY TRACKING
            dayActive: false,         // DAY TRACKING
            // BEHAVIORAL PATTERN TRACKING (V20.6)
            lastSprintCompleteTime: null,   // When last sprint finished
            consecutiveBreaks: 0,            // Break count without focus
            totalFocusTime: 0,               // Total minutes in focus this session
            totalBreakTime: 0,               // Total minutes in breaks this session
            lowEnergyChoiceCount: 0,         // Count of low energy selections
            sprintAborts: 0,                 // Count of sprints stopped early
            idleStartTime: null              // When user went idle
        };

        // ============================================
        // SESSION DATA TRACKING (ENHANCED COACHING)
        // Tracks time-based patterns for smarter coaching
        // ============================================
        const sessionData = {
            sessionStartTime: Date.now(),
            lastActionTime: Date.now(),
            breakHistory: [],
            sessionHistory: []
        };
        
        // Update last action time on any user interaction
        function updateLastAction() {
            sessionData.lastActionTime = Date.now();
        }
        
        // Initialize session history from localStorage
        function initializeSessionHistory() {
            const stored = localStorage.getItem('sessionHistory');
            if (stored) {
                sessionData.sessionHistory = JSON.parse(stored);
            }
        }
        
        // Save session to history
        function saveSessionToHistory(session) {
            sessionData.sessionHistory.push(session);
            // Keep last 30 sessions
            if (sessionData.sessionHistory.length > 30) {
                sessionData.sessionHistory = sessionData.sessionHistory.slice(-30);
            }
            localStorage.setItem('sessionHistory', JSON.stringify(sessionData.sessionHistory));
        }
        
        // Track break in history
        function trackBreak() {
            sessionData.breakHistory.push({
                time: Date.now(),
                duration: state.timer.duration
            });
            updateLastAction();
        }
        
        // Initialize on load
        initializeSessionHistory();

        // ============================================
        // VERSION & FEATURE GATING (STUDENT VERSION)
        // ============================================
        
        function hasFeature(feature) {
            const version = state.version || 'lite';
            
            const features = {
                // Core features (all versions)
                threeBuckets: ['lite', 'student', 'regular', 'premium'],
                energySelection: ['lite', 'student', 'regular', 'premium'],
                distractionParking: ['lite', 'student', 'regular', 'premium'],
                unlimitedSprints: ['lite', 'student', 'regular', 'premium'],
                
                // Analytics
                basicAnalytics: ['lite', 'student', 'regular', 'premium'],
                supabaseAnalytics: ['student', 'regular', 'premium'],
                fullAnalytics: ['premium'],
                
                // Reflections
                generalReflections: ['lite', 'student', 'regular', 'premium'],
                chooseReflectionTradition: ['student', 'regular', 'premium'],
                
                // Regular-specific
                clockBasedTracking: ['regular', 'premium'],
                
                // Student-specific
                sessionMode: ['student'],
                
                // Premium-only
                meetingMode: ['premium'],
                timeBlocking: ['premium'],
                weeklyReports: ['premium'],
                dataExport: ['premium'],
                projectManagement: ['premium']
            };
            
            return features[feature]?.includes(version) || false;
        }
        
        function getVersion() {
            // Check localStorage first, then default to lite
            try {
                const membership = localStorage.getItem('focushub_membership');
                if (membership) {
                    const data = JSON.parse(membership);
                    return data.version || 'lite';
                }
            } catch (e) {
                console.error('Error reading membership:', e);
            }
            return 'lite';
        }
        
        function initializeVersion() {
            state.version = getVersion();
            state.sessionMode = (state.version === 'student');
            console.log('üì¶ Version initialized:', state.version, 'Session mode:', state.sessionMode);
        }

        // ============================================
        // INITIALIZATION - CAREFUL WITH AUTH
        // ============================================
        async function init() {
            try {
                // Only check auth if Supabase is configured
                if (typeof supabaseClient !== 'undefined' && supabaseClient) {
                    const { data: { user } } = await supabaseClient.auth.getUser();
                    
                    if (!user) {
                        console.log('No user session, redirecting to login');
                        window.location.href = '/start.html';
                        return;
                    }
                    
                    console.log('‚úÖ User authenticated:', user.id);
                    
                    // Try to get/create membership (don't fail if it errors)
                    try {
                        const membership = await getUserMembership();
                        console.log('‚úÖ Membership:', membership ? membership.plan : 'not found');
                    } catch (membershipError) {
                        console.warn('Membership check failed:', membershipError);
                        // Continue anyway - app can work without membership
                    }
                }
            } catch (authError) {
                console.warn('Auth check failed:', authError);
                // Continue anyway - might be in dev mode
            }
            
            // Load app regardless of auth status
            loadState();
            
            // Initialize version and feature gating
            initializeVersion();
            
            // Sync theme UI with restored theme
            syncThemeUI();
            
            // CRITICAL: Set up header buttons FIRST (must work always)
            setupHeaderButtons();
            
            // Check if day expired (auto-end)
            const dayExpired = checkDayExpiration();
            if (dayExpired) return; // Already redirected
            
            // If day not active, show start-day modal
            if (!state.dayActive) {
                console.log('üìÖ Day not started - showing start modal');
                showStartDayModal();
                return; // Don't load app yet
            }
            
            // Day is active - continue normal app load
            setupEventListeners();
            setupDropZones();
            renderAll();
            
            // RESTORE MEETING MODE if it was active
            if (state.inMeeting) {
                const meetingToggle = document.getElementById('meetingToggle');
                const startBtn = document.getElementById('startSprintBtn');
                
                if (meetingToggle) meetingToggle.checked = true;
                if (startBtn) startBtn.disabled = true;
                document.querySelectorAll('.timer-btn').forEach(btn => btn.disabled = true);
                console.log('üìÖ Meeting mode restored from previous session');
            }
            
            // Record activity on any interaction
            document.addEventListener('click', recordActivity);
            document.addEventListener('keypress', recordActivity);
            
            // Sticky header with timer on scroll
            window.addEventListener('scroll', handleHeaderScroll);
            
            console.log('‚úÖ FocusHub initialized');
            
            // Check if user needs onboarding (V20.5)
            setTimeout(checkOnboarding, 500);
        }
        
        // Handle sticky header behavior
        function handleHeaderScroll() {
            const header = document.querySelector('.app-header');
            const timerSection = document.getElementById('headerTimerSection');
            const scrolled = window.scrollY > 50;
            
            if (scrolled) {
                header.classList.add('scrolled');
                // Show timer in header if sprint active
                if (state.timer.active && timerSection) {
                    timerSection.style.display = 'flex';
                }
            } else {
                header.classList.remove('scrolled');
                if (timerSection) {
                    timerSection.style.display = 'none';
                }
            }
        }

        // ============================================
        // STATE PERSISTENCE
        // ============================================
        function loadState() {
            const saved = localStorage.getItem('focushub_state');
            if (saved) {
                try {
                    Object.assign(state, JSON.parse(saved));
                } catch (error) {
                    console.error('Error loading state:', error);
                }
            }

            const savedEnergy = localStorage.getItem('focushub_energy');
            if (savedEnergy) {
                state.energyLevel = savedEnergy;
                const energySelect = document.getElementById('energyLevel');
                if (energySelect) energySelect.value = savedEnergy;
                
                const energyTimers = { low: 15, medium: 20, high: 30 };
                state.timer.duration = energyTimers[savedEnergy];
                state.timer.remaining = state.timer.duration * 60;
                updateTimerButtons();
            }
            
            // BACKGROUND TIMER: Resume timer if it was active
            if (state.timer.active && state.timer.endTime) {
                const now = Date.now();
                const timeLeft = Math.ceil((state.timer.endTime - now) / 1000);
                
                // FIX RACE CONDITION: Clear any existing interval first
                if (state.timer.interval) {
                    clearInterval(state.timer.interval);
                    state.timer.interval = null;
                }
                
                if (timeLeft > 0) {
                    // Timer still running - resume it
                    state.timer.remaining = timeLeft;
                    state.timer.interval = setInterval(() => {
                        const remaining = Math.ceil((state.timer.endTime - Date.now()) / 1000);
                        state.timer.remaining = Math.max(0, remaining);
                        updateTimerDisplay();
                        
                        if (state.timer.remaining <= 0) {
                            completeSprint();
                        }
                    }, 1000);
                    console.log('‚è±Ô∏è Timer resumed with', timeLeft, 'seconds remaining');
                } else {
                    // Timer expired while away - complete it
                    console.log('‚è±Ô∏è Timer expired while away - auto-completing');
                    state.timer.remaining = 0;
                    completeSprint();
                }
            }
        }

        function saveState() {
            try {
                localStorage.setItem('focushub_state', JSON.stringify(state));
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    console.error('‚ö†Ô∏è localStorage quota exceeded');
                    showToast('Storage full. Syncing to cloud...', 'warning');
                    
                    // Try to sync to Supabase if available
                    if (typeof syncStateToSupabase === 'function') {
                        syncStateToSupabase().catch(err => {
                            console.error('Failed to sync to cloud:', err);
                            showToast('Unable to save data. Please free up space.', 'error');
                        });
                    } else {
                        // Clear old completed tasks to free space
                        const oldWinsCount = state.tasks.wins.length;
                        state.tasks.wins = state.tasks.wins.slice(-10); // Keep only last 10 wins
                        console.log(`üßπ Cleared ${oldWinsCount - state.tasks.wins.length} old wins`);
                        
                        // Try saving again
                        try {
                            localStorage.setItem('focushub_state', JSON.stringify(state));
                            showToast('Storage space freed', 'success');
                        } catch (retryError) {
                            showToast('Critical: Unable to save', 'error');
                        }
                    }
                } else {
                    console.error('Error saving state:', error);
                    showToast('Failed to save data', 'error');
                }
            }
        }

        // ============================================
        // EVENT LISTENERS - HEADER (ALWAYS ACTIVE)
        // ============================================
        function setupHeaderButtons() {
            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Dashboard
            document.getElementById('dashboardBtn').addEventListener('click', function() {
                redirectToDashboard();
            });
            
            // End day
            document.getElementById('endDayBtn').addEventListener('click', endDay);
            
            // Logout
            document.getElementById('logoutBtn').addEventListener('click', async function() {
                if (confirm('Are you sure you want to logout?')) {
                    try {
                        // Save session stats for logout page
                        const logoutStats = {
                            sprints: state.sprintCount || 0,
                            tasks: Object.values(state.tasks).flat().filter(t => t.completed).length || 0,
                            grade: state.currentGrade || '‚Äî'
                        };
                        sessionStorage.setItem('focushub_logout_stats', JSON.stringify(logoutStats));
                        
                        // Redirect to professional logout page
                        window.location.href = 'logout.html';
                        
                    } catch (error) {
                        console.error('Logout error:', error);
                        window.location.href = 'logout.html';
                    }
                }
            });
            
            // Load and setup mode selector
            setupModeSelector();
        }
        
        // Mode Selector Management
        async function setupModeSelector() {
            let currentPlan = 'free';
            let isAdmin = false;
            
            try {
                // Get current user from Supabase
                const { data: { user }, error: userError } = await supabaseClient.auth.getUser();
                
                if (user) {
                    console.log('‚úÖ User logged in:', user.email);
                    
                    // Check membership in database
                    const { data: membership, error: membershipError } = await supabaseClient
                        .from('memberships')
                        .select('*')
                        .eq('user_id', user.id)
                        .single();
                    
                    if (!membershipError && membership) {
                        currentPlan = membership.plan || 'free';
                        isAdmin = membership.is_admin || false;
                        console.log('‚úÖ Membership loaded:', { plan: currentPlan, isAdmin: isAdmin });
                    }
                }
            } catch (error) {
                console.error('‚ùå Error loading membership:', error);
                // Fallback to localStorage if Supabase fails
                const localMembership = localStorage.getItem('focushub_membership');
                if (localMembership) {
                    try {
                        const data = JSON.parse(localMembership);
                        currentPlan = data.plan || 'free';
                        isAdmin = data.is_admin || false;
                    } catch (e) {}
                }
            }
            
            // Gate premium intensity modes
            applyFeatureGates(currentPlan, isAdmin);
            
            // Load reflection tradition
            const tradition = localStorage.getItem('focushub_reflection_tradition') || 'secular';
            const traditionSelect = document.getElementById('reflectionTradition');
            if (traditionSelect) {
                traditionSelect.value = tradition;
            }
            
            // Membership change UI (removed - now handled in settings page)
            // Legacy code removed to prevent errors
            
            // Load current mode from state and set active switch button
            const switchButtons = document.querySelectorAll('.switch-btn');
            switchButtons.forEach(btn => {
                if (btn.dataset.mode === state.currentMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // AI intensity switch button handlers
            switchButtons.forEach(btn => {
                btn.addEventListener('click', async function() {
                    const selectedMode = this.dataset.mode;
                    
                    // Check if premium required (client-side first for UX)
                    if ((selectedMode === 'supportive' || selectedMode === 'tough') && currentPlan !== 'premium' && !isAdmin) {
                        alert('üîí This intensity mode requires Premium. Upgrade to unlock Supportive & Tough modes.');
                        return;
                    }
                    
                    // SECURITY: Verify with server for premium modes
                    if (selectedMode === 'supportive' || selectedMode === 'tough') {
                        const verified = await verifyPremiumAccess('This AI intensity mode');
                        if (!verified) return;
                    }
                    
                    // Update state
                    state.currentMode = selectedMode;
                    saveState();
                    console.log('Intensity changed to:', selectedMode);
                    
                    // Update button states
                    switchButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                });
            });
        }
        
        // Apply feature gates based on membership
        function applyFeatureGates(plan, isAdmin = false) {
            const isPremium = plan === 'premium' || isAdmin;
            
            // Gate AI intensity modes
            const agentModeSelect = document.getElementById('agentMode');
            if (agentModeSelect) {
                ['supportive', 'tough'].forEach(mode => {
                    const option = agentModeSelect.querySelector(`[value="${mode}"]`);
                    if (option) {
                        option.disabled = !isPremium;
                        if (!isPremium && !option.textContent.includes('üîí')) {
                            option.textContent = option.textContent.replace(' üîí', '') + ' üîí';
                        }
                    }
                });
                
                // Force balanced if not premium
                if (!isPremium && (state.currentMode === 'supportive' || state.currentMode === 'tough')) {
                    state.currentMode = 'balanced';
                    agentModeSelect.value = 'balanced';
                }
            }
        }
        
        // SECURITY: Verify premium status with server before allowing premium features
        async function verifyPremiumAccess(featureName = 'premium feature') {
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) {
                    showToast('Please log in to continue', 'error');
                    return false;
                }
                
                const { data: membership, error } = await supabaseClient
                    .from('memberships')
                    .select('plan, is_admin')
                    .eq('user_id', user.id)
                    .single();
                
                if (error) {
                    console.error('Membership verification failed:', error);
                    showToast('Unable to verify access', 'error');
                    return false;
                }
                
                const isPremium = membership.plan === 'premium' || membership.is_admin;
                
                if (!isPremium) {
                    showToast(`${featureName} requires Premium`, 'warning');
                    // Optionally redirect to upgrade
                    setTimeout(() => {
                        if (confirm('Upgrade to Premium to unlock this feature?')) {
                            window.location.href = 'upgrade.html';
                        }
                    }, 500);
                    return false;
                }
                
                return true;
                
            } catch (error) {
                console.error('Premium verification error:', error);
                return false;
            }
        }
        
        // SECURITY: Sanitize HTML to prevent XSS attacks
        function sanitizeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }
        
        // SECURITY: Sanitize for attribute values
        function sanitizeAttribute(str) {
            if (!str) return '';
            return str.replace(/[<>"']/g, '');
        }

        // ============================================
        // EVENT LISTENERS - APP CONTENT
        // ============================================
        function setupEventListeners() {
            // Collapsible
            document.getElementById('distractionHeader').addEventListener('click', function() {
                const content = document.getElementById('distractionContent');
                const icon = this.querySelector('.collapse-icon');
                content.classList.toggle('collapsed');
                icon.textContent = content.classList.contains('collapsed') ? '‚ñº' : '‚ñ≤';
            });

            // Timer buttons
            document.querySelectorAll('.timer-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // V20.6: Check if attempting to select break
                    const isBreakBtn = this.classList.contains('timer-btn-break');
                    const duration = parseInt(this.dataset.duration);
                    
                    if (isBreakBtn && duration === 5) {
                        // Check if break is earned
                        if (!checkBreakEligibility()) {
                            return; // Block break selection
                        }
                    }
                    
                    document.querySelectorAll('.timer-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    state.timer.duration = duration;
                    state.timer.remaining = state.timer.duration * 60;
                    
                    // Mark as break type if break button
                    if (isBreakBtn) {
                        state.timer.type = 'break';
                    } else {
                        state.timer.type = 'focus';
                    }
                    
                    updateTimerDisplay();
                    saveState();
                });
            });

            // Energy selector
            document.getElementById('energyLevel').addEventListener('change', function() {
                state.energyLevel = this.value;
                localStorage.setItem('focushub_energy', this.value);
                
                // V20.6: Track low-energy selections
                if (this.value === 'low') {
                    state.lowEnergyChoiceCount++;
                    saveState();
                    
                    // Check for priority mismatch pattern
                    checkPriorityMismatch();
                }
                
                const energyTimers = { low: 15, medium: 20, high: 30 };
                state.timer.duration = energyTimers[this.value];
                state.timer.remaining = state.timer.duration * 60;
                updateTimerButtons();
                updateTimerDisplay();
                saveState();
            });

            // Meeting toggle
            document.getElementById('meetingToggle').addEventListener('change', function() {
                toggleMeetingMode(this.checked);
            });

            // Note: Agent mode (intensity) is now handled by switch buttons in setupModeSelector()

            // Start sprint
            document.getElementById('startSprintBtn').addEventListener('click', startSprint);

            // Parse tasks
            document.getElementById('parseBtn').addEventListener('click', parseTasks);

            // Park distraction
            document.getElementById('parkBtn').addEventListener('click', parkDistraction);
        }

        // ============================================
        // TASK FUNCTIONS
        // ============================================
        function parseTasks() {
            const input = document.getElementById('taskInput').value.trim();
            if (!input) return;
            
            const tasks = input.split('\n').filter(t => t.trim());
            
            console.log('üìù Adding tasks:', {
                input: input,
                parsed: tasks,
                holdingBefore: state.tasks.holding.length
            });
            
            tasks.forEach(taskText => {
                const task = {
                    id: 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    text: taskText.trim().replace(/</g, '&lt;').replace(/>/g, '&gt;'),
                    sprints: 1,
                    priority: 'medium', // Default priority
                    completed: false,
                    bucket: 'holding'
                };
                state.tasks.holding.push(task);
            });
            
            console.log('üìù After adding:', {
                holdingAfter: state.tasks.holding.length,
                tasks: state.tasks.holding
            });
            
            document.getElementById('taskInput').value = '';
            saveState();
            renderAll();
            showMicroConfirm('Tasks added to holding area');
        }

        function renderTasks() {
            ['holding', 'admin', 'deepwork', 'strategic'].forEach(bucket => {
                const container = document.getElementById(bucket === 'holding' ? 'holdingTasks' : `${bucket}Bucket`);
                const tasks = state.tasks[bucket] || []; // SAFETY CHECK
                
                if (!container) return; // SAFETY CHECK
                
                // COLLAPSE holding area when empty
                if (bucket === 'holding') {
                    const holdingArea = document.querySelector('.holding-area');
                    if (tasks.length === 0) {
                        holdingArea.classList.add('collapsed');
                    } else {
                        holdingArea.classList.remove('collapsed');
                    }
                }
                
                if (tasks.length === 0) {
                    container.innerHTML = bucket === 'holding' 
                        ? '<p class="empty-state">[ AWAITING_INPUT ]</p>'
                        : '<p class="empty-state-small">[ AWAITING_INPUT ]</p>';
                } else {
                    container.innerHTML = tasks.map(task => {
                        // Priority indicator - per task, not bucket
                        const priority = task.priority || 'medium'; // default to medium
                        const priorityClass = `priority-${priority}`;
                        const priorityTitle = priority === 'high' ? 'High Priority' : priority === 'medium' ? 'Medium Priority' : 'Low Priority';
                        
                        return `
                        <div class="task-item" draggable="true" data-task-id="${sanitizeAttribute(task.id)}" data-bucket="${sanitizeAttribute(bucket)}">
                            <button class="priority-indicator ${priorityClass}" 
                                    data-task-id="${sanitizeAttribute(task.id)}" 
                                    title="${sanitizeAttribute(priorityTitle)} - Click to change"
                                    draggable="false"></button>
                            ${bucket !== 'holding' ? `<input type="checkbox" class="task-checkbox" draggable="false" data-task-id="${sanitizeAttribute(task.id)}" data-bucket="${sanitizeAttribute(bucket)}">` : ''}
                            <div class="task-text">${sanitizeHTML(task.text)}</div>
                            <div class="task-controls">${bucket !== 'holding' ? `
                                <div class="sprint-controls">
                                    <div class="sprint-arrows">
                                        <button class="sprint-up" data-task-id="${sanitizeAttribute(task.id)}" data-action="increment">‚ñ≤</button>
                                        <button class="sprint-down" data-task-id="${sanitizeAttribute(task.id)}" data-action="decrement">‚ñº</button>
                                    </div>
                                    <span class="sprint-value">${task.sprints || 1}</span>
                                </div>
                                ` : ''}
                                <button class="task-delete" data-task-id="${task.id}" data-bucket="${bucket}">√ó</button>
                            </div>
                        </div>
                    `;
                    }).join('');
                    
                    // Add event listeners to checkboxes (complete task)
                    container.querySelectorAll('.task-checkbox').forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            if (e.target.checked) {
                                completeTask(checkbox.dataset.taskId, checkbox.dataset.bucket);
                            }
                        });
                    });
                    
                    // Add event listeners to buttons
                    container.querySelectorAll('.sprint-up').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            adjustSprints(btn.dataset.taskId, 1);
                        });
                    });
                    
                    container.querySelectorAll('.sprint-down').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            adjustSprints(btn.dataset.taskId, -1);
                        });
                    });
                    
                    container.querySelectorAll('.priority-indicator').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            cyclePriority(btn.dataset.taskId);
                        });
                    });
                    
                    container.querySelectorAll('.task-delete').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deleteTask(btn.dataset.taskId, btn.dataset.bucket);
                        });
                    });
                    
                    container.querySelectorAll('.task-item').forEach(setupDragAndDrop);
                }
                
                const countEl = document.getElementById(bucket === 'holding' ? 'holdingCount' : `${bucket}Count`);
                if (countEl) countEl.textContent = tasks.length;
            });
        }

        function setupDragAndDrop(taskEl) {
            taskEl.addEventListener('dragstart', function(e) {
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                e.dataTransfer.setData('sourceBucket', this.dataset.bucket);
                this.classList.add('dragging');
            });

            taskEl.addEventListener('dragend', function() {
                this.classList.remove('dragging');
            });
        }

        function setupDropZones() {
            // Use event delegation on task-section (never gets replaced)
            const taskSection = document.querySelector('.task-section');
            if (!taskSection) return;
            
            // Dragover handler (delegated)
            taskSection.addEventListener('dragover', function(e) {
                const dropZone = e.target.closest('.task-list');
                if (!dropZone) return;
                
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                dropZone.classList.add('drag-over');
            });
            
            // Dragleave handler (delegated)
            taskSection.addEventListener('dragleave', function(e) {
                const dropZone = e.target.closest('.task-list');
                if (!dropZone) return;
                
                // Only remove if actually leaving the drop zone
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('drag-over');
                }
            });
            
            // Drop handler (delegated)
            taskSection.addEventListener('drop', function(e) {
                const dropZone = e.target.closest('.task-list');
                if (!dropZone) return;
                
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                
                const taskId = e.dataTransfer.getData('text/plain');
                const sourceBucket = e.dataTransfer.getData('sourceBucket');
                const targetBucket = dropZone.dataset.bucket;
                
                if (sourceBucket === targetBucket) return;
                
                moveTask(taskId, sourceBucket, targetBucket);
            });
        }

        function moveTask(taskId, fromBucket, toBucket) {
            const taskIndex = state.tasks[fromBucket].findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            
            const task = state.tasks[fromBucket].splice(taskIndex, 1)[0];
            task.bucket = toBucket;
            state.tasks[toBucket].push(task);
            
            // AI COACH: Task reclassification
            const message = getAICoachMessage('taskMoved', {
                toBucket: toBucket,
                fromBucket: fromBucket
            });
            updateAIMessage(message);
            
            saveState();
            renderAll();
            showMicroConfirm('Priority updated');
        }

        window.adjustSprints = function(taskId, delta) {
            for (let bucket in state.tasks) {
                const task = state.tasks[bucket].find(t => t.id === taskId);
                if (task) {
                    const oldSprints = task.sprints || 1;
                    task.sprints = Math.max(1, Math.min(5, (task.sprints || 1) + delta));
                    const newSprints = task.sprints;
                    
                    // AI COACH: Sprint estimation changes
                    if (newSprints !== oldSprints) {
                        const totalRequired = calculateTotalRequiredSprints();
                        const message = getAICoachMessage('sprintAdjusted', {
                            oldSprints: oldSprints,
                            newSprints: newSprints,
                            totalRequired: totalRequired
                        });
                        updateAIMessage(message);
                    }
                    
                    saveState();
                    renderAll(); // Changed from renderTasks() to update sprint counts everywhere
                    return;
                }
            }
        };

        window.cyclePriority = function(taskId) {
            for (let bucket in state.tasks) {
                const task = state.tasks[bucket].find(t => t.id === taskId);
                if (task) {
                    // Cycle: low ‚Üí medium ‚Üí high ‚Üí low
                    if (task.priority === 'low') task.priority = 'medium';
                    else if (task.priority === 'medium') task.priority = 'high';
                    else task.priority = 'low';
                    
                    saveState();
                    renderTasks();
                    return;
                }
            }
        };

        window.deleteTask = function(taskId, bucket) {
            state.tasks[bucket] = state.tasks[bucket].filter(t => t.id !== taskId);
            saveState();
            renderAll();
        };

        window.completeTask = function(taskId, bucket) {
            const taskIndex = state.tasks[bucket].findIndex(t => t.id === taskId);
            if (taskIndex !== -1) {
                const task = state.tasks[bucket][taskIndex];
                task.completed = true;
                task.completedAt = new Date().toISOString();
                
                // Move to wins
                state.tasks.wins.push(task);
                
                // Remove from current bucket
                state.tasks[bucket].splice(taskIndex, 1);
                
                // Update stats
                state.sprintCount += task.sprints || 1;
                
                // AI COACH: Contextual task completion message
                const tasksLeft = ['admin', 'deepwork', 'strategic'].reduce((sum, b) => 
                    sum + state.tasks[b].filter(t => !t.completed).length, 0);
                
                const message = getAICoachMessage('taskComplete', {
                    priority: task.priority || 'medium',
                    sprintValue: task.sprints || 1,
                    tasksLeft: tasksLeft
                });
                
                updateAIMessage(message);
                
                saveState();
                renderAll();
                showMicroConfirm(`‚úì Task completed! +${task.sprints || 1} sprint${task.sprints > 1 ? 's' : ''}`);
            }
        };

        // SMART DASHBOARD REDIRECT: Route based on plan
        function redirectToDashboard() {
            // V21: Proper tier-based routing
            // FREE tier ‚Üí overview.html (localStorage only, basic stats)
            // PREMIUM tier ‚Üí dashboard.html (Supabase sync, advanced analytics)
            
            let tier = 'free';
            
            // Check membership tier from localStorage
            try {
                const membership = localStorage.getItem('focushub_membership');
                if (membership) {
                    const data = JSON.parse(membership);
                    tier = data.tier || 'free';
                }
            } catch (e) {
                console.log('Could not parse membership, defaulting to free tier');
            }
            
            // Route based on tier
            if (tier === 'premium') {
                console.log('üéØ Premium user ‚Üí dashboard.html (Supabase analytics)');
                window.location.href = 'dashboard.html';
            } else {
                console.log('üéØ Free user ‚Üí overview.html (localStorage stats)');
                window.location.href = 'overview.html';
            }
        }
        
        function endDay() {
            if (confirm('Session complete. Today\'s work has been logged. The session is closed.')) {
                // Move incomplete tasks back to holding
                ['admin', 'deepwork', 'strategic'].forEach(bucket => {
                    state.tasks[bucket].forEach(task => {
                        if (!task.completed) {
                            task.bucket = 'holding';
                            state.tasks.holding.push(task);
                        }
                    });
                    state.tasks[bucket] = [];
                });
                
                // Clear wins for new day
                state.tasks.wins = [];
                
                // Reset counts
                state.sprintCount = 0;
                state.breaksCount = 0;
                state.distractionCount = 0;
                
                // DAY TRACKING: Mark day as ended
                state.dayActive = false;
                state.lastDayStarted = null;
                state.lastActivityTime = null;
                
                saveState();
                
                // Redirect to appropriate dashboard
                redirectToDashboard();
            }
        }

        // DAY TRACKING: Check if day should auto-end (midnight + 2 hrs inactivity)
        function checkDayExpiration() {
            if (!state.dayActive || !state.lastDayStarted) return false;
            
            const now = new Date();
            const startDate = new Date(state.lastDayStarted);
            const lastActivity = state.lastActivityTime ? new Date(state.lastActivityTime) : now;
            
            // Check if it's a different day
            const isDifferentDay = now.getDate() !== startDate.getDate() || 
                                   now.getMonth() !== startDate.getMonth() || 
                                   now.getFullYear() !== startDate.getFullYear();
            
            // Calculate hours since last activity
            const hoursInactive = (now - lastActivity) / (1000 * 60 * 60);
            
            // Auto-end if: different day AND 2+ hours inactive
            if (isDifferentDay && hoursInactive >= 2) {
                console.log('üåô Auto-ending day: new day + 2hrs inactivity');
                state.dayActive = false;
                state.lastDayStarted = null;
                state.lastActivityTime = null;
                saveState();
                alert('Session ended. Previous day logged.');
                redirectToDashboard();
                return true;
            }
            
            return false;
        }

        // DAY TRACKING: Update activity timestamp on any interaction
        function recordActivity() {
            state.lastActivityTime = Date.now();
            saveState();
        }

        // ============================================
        // TIMER FUNCTIONS
        // ============================================
        // ============================================
        // MEETING MODE
        // ============================================
        function toggleMeetingMode(enabled) {
            state.inMeeting = enabled;
            
            if (enabled) {
                // PAUSE/STOP active sprint
                if (state.timer.active) {
                    clearInterval(state.timer.interval);
                    state.timer.active = false;
                    state.timer.startTime = null;
                    state.timer.endTime = null;
                    state.sessionState = 'meeting';
                }
                
                // DISABLE sprint controls - with safety checks
                const startBtn = document.getElementById('startSprintBtn');
                if (startBtn) startBtn.disabled = true;
                document.querySelectorAll('.timer-btn').forEach(btn => btn.disabled = true);
                
                // UPDATE AI message
                updateAIMessage('ü§ù In meeting mode. Timer paused, no performance tracking. Resume when ready.');
                updateSystemState('[ MEETING_MODE_ACTIVE ]');
                
                console.log('üìÖ Meeting mode: ENABLED');
            } else {
                // RE-ENABLE sprint controls - with safety checks
                const startBtn = document.getElementById('startSprintBtn');
                if (startBtn) startBtn.disabled = false;
                document.querySelectorAll('.timer-btn').forEach(btn => btn.disabled = false);
                state.sessionState = 'idle';
                
                // UPDATE AI message
                const totalRequired = calculateTotalRequiredSprints();
                const message = getAICoachMessage('resumeFromMeeting', { required: totalRequired });
                updateAIMessage(message);
                updateSystemState('[ READY ]');
                
                console.log('üìÖ Meeting mode: DISABLED');
            }
            
            saveState();
            renderAll();
        }

        // ============================================
        // SPRINT TIMER FUNCTIONS
        // ============================================
        function startSprint() {
            if (state.timer.active) return;
            if (state.inMeeting) {
                showMicroConfirm('Cannot start sprint while in meeting mode');
                return;
            }
            
            // V20.6: Reset idle tracking when starting sprint
            state.idleStartTime = null;
            
            // FIX RACE CONDITION: Clear any existing interval first
            if (state.timer.interval) {
                clearInterval(state.timer.interval);
                state.timer.interval = null;
            }

            // TIMESTAMP-BASED TIMER: Record start and end times
            const now = Date.now();
            state.timer.startTime = now;
            state.timer.endTime = now + (state.timer.duration * 60 * 1000);
            state.timer.active = true;
            state.timer.type = 'focus';
            state.sessionState = 'active';
            
            const totalRequired = calculateTotalRequiredSprints();
            const message = getAICoachMessage('sessionStart', { required: totalRequired });
            
            updateSystemState(message);
            updateAIMessage(message);
            resetInactivityMonitor();
            
            // IMMEDIATE DISPLAY UPDATE - Show timer right away
            updateTimerDisplay();
            
            state.timer.interval = setInterval(() => {
                // Calculate remaining time from end time
                const timeLeft = Math.ceil((state.timer.endTime - Date.now()) / 1000);
                state.timer.remaining = Math.max(0, timeLeft);
                updateTimerDisplay();
                
                if (state.timer.remaining <= 0) {
                    completeSprint();
                }
            }, 1000);
            
            saveState();
        }
        
        // V20.6: Separate break start function
        function startBreak() {
            if (state.timer.active) return;
            if (!checkBreakEligibility()) return;
            
            state.idleStartTime = null;
            
            if (state.timer.interval) {
                clearInterval(state.timer.interval);
                state.timer.interval = null;
            }

            const now = Date.now();
            state.timer.startTime = now;
            state.timer.endTime = now + (5 * 60 * 1000); // 5-minute break
            state.timer.active = true;
            state.timer.type = 'break';
            state.timer.duration = 5;
            state.timer.remaining = 300;
            state.sessionState = 'break';
            
            // ENHANCED COACHING: Track break
            trackBreak();
            
            updateAIMessage('Break started. Return to focus after.');
            resetInactivityMonitor();
            updateTimerDisplay();
            
            state.timer.interval = setInterval(() => {
                const timeLeft = Math.ceil((state.timer.endTime - Date.now()) / 1000);
                state.timer.remaining = Math.max(0, timeLeft);
                updateTimerDisplay();
                
                if (state.timer.remaining <= 0) {
                    completeSprint();
                }
            }, 1000);
            
            saveState();
        }

        function completeSprint() {
            clearInterval(state.timer.interval);
            
            // V20.6: Track focus vs break time
            if (state.timer.type === 'focus') {
                state.totalFocusTime += state.timer.duration;
                state.consecutiveBreaks = 0; // Reset break counter on focus
            } else if (state.timer.type === 'break') {
                state.totalBreakTime += state.timer.duration;
                state.consecutiveBreaks++;
            }
            
            state.timer.active = false;
            state.timer.startTime = null;
            state.timer.endTime = null;
            
            // Only increment sprint count for actual focus sessions
            if (state.timer.type === 'focus') {
                state.sprintCount++;
                state.lastSprintCompleteTime = Date.now();
            }
            
            state.sessionState = 'idle';
            state.timer.remaining = state.timer.duration * 60;
            state.idleStartTime = Date.now(); // V20.6: Start idle tracking
            
            // Only show sprint complete messages for focus sessions
            if (state.timer.type === 'focus') {
                // System Intelligence: Contextual performance feedback
                const totalRequired = calculateTotalRequiredSprints();
                const tasksLeft = ['admin', 'deepwork', 'strategic'].reduce((sum, bucket) => 
                    sum + state.tasks[bucket].filter(t => !t.completed).length, 0);
                
                const message = getAICoachMessage('sprintComplete', {
                    sprintsDone: state.sprintCount,
                    required: totalRequired,
                    tasksLeft: tasksLeft
                });
                
                updateAIMessage(message);
                
                // Check priority alignment
                setTimeout(() => checkPriorityAlignment(), 2000);
            }
            
            // Start inactivity monitor
            startInactivityMonitor();
            
            // Start continuous monitoring
            startAIMonitoring();
            
            saveState();
            renderAll();
        }

        function updateTimerButtons() {
            const duration = state.timer.duration;
            document.querySelectorAll('.timer-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.duration) === duration) {
                    btn.classList.add('active');
                }
            });
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(state.timer.remaining / 60);
            const seconds = state.timer.remaining % 60;
            const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update timer display in card
            const valueEl = document.querySelector('.timer-value');
            const statusEl = document.querySelector('.timer-status');
            
            if (valueEl) valueEl.textContent = timeStr;
            if (statusEl) {
                statusEl.textContent = state.timer.active ? 'In progress' : 'Ready to start';
            }
            
            // Update sticky header timer (if scrolled)
            const stickyTimer = document.getElementById('stickyTimer');
            if (stickyTimer) {
                stickyTimer.textContent = timeStr;
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================
        function renderAll() {
            // Calculate total required sprints from all tasks
            const totalRequiredSprints = calculateTotalRequiredSprints();
            
            // DEBUG: Log sprint calculation
            console.log('üìä Sprint Calc:', {
                required: totalRequiredSprints,
                done: state.sprintCount,
                gap: totalRequiredSprints - state.sprintCount,
                tasks: {
                    admin: state.tasks.admin.length,
                    deepwork: state.tasks.deepwork.length,
                    strategic: state.tasks.strategic.length
                }
            });
            
            // SAFETY CHECKS: Only update elements if they exist
            const sprintsDoneEl = document.getElementById('sprintsDone');
            const sprintTargetEl = document.getElementById('sprintTarget');
            const sprintsTotalEl = document.getElementById('sprintsTotal');
            const winsCountEl = document.getElementById('winsCount');
            const breaksCountEl = document.getElementById('breaksCount');
            const distractionsCountEl = document.getElementById('distractionsCount');
            const distractionCountDisplayEl = document.getElementById('distractionCountDisplay');
            
            if (sprintsDoneEl) sprintsDoneEl.textContent = state.sprintCount;
            if (sprintTargetEl) sprintTargetEl.textContent = totalRequiredSprints;
            if (sprintsTotalEl) sprintsTotalEl.textContent = totalRequiredSprints;  // FIX: Update main counter display
            if (winsCountEl) winsCountEl.textContent = state.tasks.wins.length;
            if (breaksCountEl) breaksCountEl.textContent = state.breaksCount;
            if (distractionsCountEl) distractionsCountEl.textContent = state.distractionCount;
            if (distractionCountDisplayEl) distractionCountDisplayEl.textContent = state.distractionCount;
            
            renderTasks();
            renderWins();
            
            // Update AI coach with current context if not in active sprint
            if (!state.timer.active && state.dayActive) {
                const gap = totalRequiredSprints - state.sprintCount;
                if (state.sprintCount > 0) {
                    // User has done work - acknowledge it
                    const message = getAICoachMessage('idleState', { gap: gap });
                    updateAIMessage(message);
                }
            }
        }
        
        // Calculate total required sprints from ALL tasks (active + completed)
        function calculateTotalRequiredSprints() {
            let total = 0;
            let taskDetails = [];
            
            // Count sprints from ACTIVE tasks
            ['admin', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    const sprints = parseInt(task.sprints) || 1;
                    total += sprints;
                    taskDetails.push(`${task.title}: ${sprints}`);
                });
            });
            
            // ALSO count completed tasks (in wins) - they count toward total
            state.tasks.wins.forEach(task => {
                const sprints = parseInt(task.sprints) || 1;
                total += sprints;
                taskDetails.push(`${task.title} (‚úì): ${sprints}`);
            });
            
            // Default minimum of 5 sprints if no tasks
            const finalTotal = Math.max(5, total);
            
            console.log('üìä Sprint Total Calculation:', {
                activeTasks: state.tasks.admin.length + state.tasks.deepwork.length + state.tasks.strategic.length,
                completedTasks: state.tasks.wins.length,
                totalSprints: finalTotal,
                sprintsDone: state.sprintCount,
                details: taskDetails
            });
            
            return finalTotal;
        }

        function renderWins() {
            const winsList = document.getElementById('winsList');
            const winsCount = document.getElementById('winsDisplayCount');
            const winsSection = document.getElementById('winsSection');
            
            if (!winsList) return;
            
            winsCount.textContent = state.tasks.wins.length;
            
            // Show/hide entire section based on wins
            if (state.tasks.wins.length === 0) {
                if (winsSection) winsSection.classList.add('hidden');
            } else {
                if (winsSection) winsSection.classList.remove('hidden');
                winsList.innerHTML = state.tasks.wins.map(win => `
                    <div class="win-item">
                        <span class="win-text">${sanitizeHTML(win.text)}</span>
                        <span class="win-sprints">+${win.sprints || 1}</span>
                    </div>
                `).join('');
            }
        }

        // Grade removed per Studio Deck refactor - gamification eliminated

        function updateSystemState(message) {
            const systemStateEl = document.getElementById('systemState');
            if (!systemStateEl) return; // Safety check
            systemStateEl.textContent = message;
        }

        function updateAIMessage(message) {
            const aiMessageEl = document.getElementById('aiMessage');
            if (!aiMessageEl) return;
            
            aiMessageEl.textContent = message;
            
            // DON'T auto-reset to idle - keep the coach aware and persistent
            // Messages stay until something important happens
            // The coach should reflect actual state, not timeout to generic messages
        }

        // ============================================
        // ENHANCED CONTEXT CALCULATION FUNCTIONS
        // Time awareness, pattern recognition, humanity
        // ============================================
        
        function getEnhancedContext(baseContext) {
            const now = new Date();
            const currentHour = now.getHours();
            
            // Time awareness
            const minutesSinceLastAction = calculateMinutesSinceLastAction();
            const hoursSinceLastSession = calculateHoursSinceLastSession();
            
            // Today's stats
            const todayFocusTime = getTodayTotalFocusMinutes();
            const todayBreakTime = getTodayTotalBreakMinutes();
            const todaySessionCount = getTodaySessionCount();
            
            // Yesterday comparison
            const yesterdayFocusTime = getYesterdayFocusMinutes();
            const consecutiveDays = getConsecutiveDaysStreak();
            
            // Current session
            const sessionStartTime = sessionData.sessionStartTime || now;
            const sessionMinutes = Math.floor((now - sessionStartTime) / 60000);
            const sessionJustStarted = sessionMinutes < 5;
            
            // Behavioral patterns
            const avgSessionLength = getAverageSessionLength();
            const avgTimeBeforeAbort = getAverageAbortTime();
            const timeBetweenBreaks = getTimeBetweenLastTwoBreaks();
            
            return {
                ...baseContext,
                // Time context
                timeOfDay: currentHour,
                minutesSinceLastAction,
                hoursSinceLastSession,
                sessionJustStarted,
                sessionMinutes,
                
                // Today vs Yesterday
                todayFocusTime,
                yesterdayFocusTime,
                todayBreakTime,
                todaySessionCount,
                consecutiveDays,
                
                // Patterns
                avgSessionLength,
                avgTimeBeforeAbort,
                timeBetweenBreaks,
                
                // Session info
                previousSessionMinutes: getPreviousSessionDuration(),
                previousSessionLong: getPreviousSessionDuration() > 60,
                
                // Student-specific context
                sessionNumber: state.currentStudySession || todaySessionCount,
                lastSessionAborted: getLastSessionAborted()
            };
        }
        
        function getLastSessionAborted() {
            const sessions = getSessionHistory();
            if (sessions.length === 0) return false;
            const lastSession = sessions[sessions.length - 1];
            return lastSession.aborted || false;
        }
        
        function calculateMinutesSinceLastAction() {
            if (!sessionData.lastActionTime) return 0;
            return Math.floor((Date.now() - sessionData.lastActionTime) / 60000);
        }
        
        function calculateHoursSinceLastSession() {
            const sessions = getSessionHistory();
            if (sessions.length < 2) return 0;
            const lastSessionEnd = sessions[sessions.length - 2].endTime;
            if (!lastSessionEnd) return 0;
            return Math.floor((Date.now() - lastSessionEnd) / 3600000);
        }
        
        function getTodayTotalFocusMinutes() {
            const today = new Date().toDateString();
            const sessions = getSessionHistory().filter(s => 
                new Date(s.startTime).toDateString() === today
            );
            return sessions.reduce((sum, s) => sum + (s.focusMinutes || 0), 0);
        }
        
        function getTodayTotalBreakMinutes() {
            const today = new Date().toDateString();
            const sessions = getSessionHistory().filter(s => 
                new Date(s.startTime).toDateString() === today
            );
            return sessions.reduce((sum, s) => sum + (s.breakMinutes || 0), 0);
        }
        
        function getTodaySessionCount() {
            const today = new Date().toDateString();
            return getSessionHistory().filter(s => 
                new Date(s.startTime).toDateString() === today
            ).length;
        }
        
        function getYesterdayFocusMinutes() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toDateString();
            const sessions = getSessionHistory().filter(s => 
                new Date(s.startTime).toDateString() === yesterdayStr
            );
            return sessions.reduce((sum, s) => sum + (s.focusMinutes || 0), 0);
        }
        
        function getConsecutiveDaysStreak() {
            // Simple implementation - can be enhanced
            const streak = parseInt(localStorage.getItem('consecutiveDaysStreak') || '0');
            return streak;
        }
        
        function getAverageSessionLength() {
            const sessions = getSessionHistory().filter(s => s.duration > 0);
            if (sessions.length === 0) return 0;
            const total = sessions.reduce((sum, s) => sum + s.duration, 0);
            return Math.floor(total / sessions.length);
        }
        
        function getAverageAbortTime() {
            const aborted = getSessionHistory().filter(s => s.aborted && s.duration > 0);
            if (aborted.length === 0) return 0;
            const total = aborted.reduce((sum, s) => sum + s.duration, 0);
            return Math.floor(total / aborted.length);
        }
        
        function getTimeBetweenLastTwoBreaks() {
            const breaks = sessionData.breakHistory || [];
            if (breaks.length < 2) return 0;
            const lastTwo = breaks.slice(-2);
            return Math.floor((lastTwo[1].time - lastTwo[0].time) / 60000);
        }
        
        function getPreviousSessionDuration() {
            const sessions = getSessionHistory();
            if (sessions.length < 2) return 0;
            return sessions[sessions.length - 2].duration || 0;
        }
        
        function getSessionHistory() {
            const history = localStorage.getItem('sessionHistory');
            return history ? JSON.parse(history) : [];
        }

        // ============================================
        // SYSTEM INTELLIGENCE COMPLETE LIBRARY
        // 3 Intensity Levels + Contextual Intelligence
        // 150+ Total Messages for Variety
        // ENHANCED WITH TIME/PATTERN AWARENESS
        // ============================================
        
        const aiCoachLibrary = {
            // SPRINT COMPLETION - Context: sprintsDone, required, tasksLeft
            sprintComplete: {
                supportive: [
                    (ctx) => `Great work completing sprint ${ctx.sprintsDone}! ${ctx.required - ctx.sprintsDone} more to go. You've got this!`,
                    (ctx) => `Sprint ${ctx.sprintsDone} done! Taking it one step at a time. ${ctx.tasksLeft} tasks remaining.`,
                    (ctx) => `Nice! Sprint ${ctx.sprintsDone} complete. Keep that momentum going!`,
                    (ctx) => `Excellent focus! Sprint ${ctx.sprintsDone} finished. You're building real progress.`,
                    (ctx) => `Sprint complete! That's ${ctx.sprintsDone} down. You're doing great work here.`,
                    (ctx) => `Another sprint in the books! ${ctx.required - ctx.sprintsDone} to go. Stay strong!`,
                    (ctx) => `Wonderful! Sprint ${ctx.sprintsDone} complete. ${ctx.tasksLeft} tasks still on the board.`
                ],
                balanced: [
                    (ctx) => `Sprint ${ctx.sprintsDone}/${ctx.required} complete. ${ctx.required - ctx.sprintsDone > 0 ? 'Continue execution.' : 'On track.'}`,
                    (ctx) => `Sprint logged. ${ctx.tasksLeft} task${ctx.tasksLeft !== 1 ? 's' : ''} remaining. Maintain pace.`,
                    (ctx) => `Sprint ${ctx.sprintsDone} done. ${ctx.required - ctx.sprintsDone} sprint${ctx.required - ctx.sprintsDone !== 1 ? 's' : ''} left in requirements.`,
                    (ctx) => `Work session complete. ${ctx.sprintsDone} of ${ctx.required} finished. Progress acceptable.`,
                    (ctx) => `Sprint logged. ${ctx.required - ctx.sprintsDone} remaining. ${ctx.tasksLeft} tasks active.`,
                    (ctx) => `Session ${ctx.sprintsDone} complete. Continue at current pace.`,
                    (ctx) => `Sprint finished. ${ctx.required - ctx.sprintsDone} more needed to meet daily target.`
                ],
                tough: [
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        if (gap > 5) return `Sprint ${ctx.sprintsDone}/${ctx.required} complete. You're ${gap} sprints behind. Deficit severe. Start now.`;
                        if (gap > 3) return `Sprint ${ctx.sprintsDone}/${ctx.required} complete. ${gap} sprints behind. This gap won't close itself. Move.`;
                        if (gap > 0) return `Sprint ${ctx.sprintsDone}/${ctx.required} logged. Still ${gap} behind target. Pick up the pace.`;
                        return `Sprint complete. ${ctx.tasksLeft} task${ctx.tasksLeft !== 1 ? 's' : ''} remaining. No time to celebrate.`;
                    },
                    (ctx) => `Sprint done. ${ctx.required - ctx.sprintsDone} more required. Clock's ticking. Execute.`,
                    (ctx) => `Sprint ${ctx.sprintsDone} logged. ${ctx.tasksLeft} items still need execution. Results matter, not effort.`,
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        return gap > 4 ? `${ctx.sprintsDone} done. ${gap} behind. Performance unacceptable. Immediate action required.` : `Sprint logged. ${gap} remain. Move faster.`;
                    },
                    (ctx) => `Sprint complete. ${ctx.required - ctx.sprintsDone} still needed. Every delay compounds. Next.`,
                    (ctx) => `One sprint finished. ${ctx.required - ctx.sprintsDone} pending. Speed insufficient. Accelerate now.`,
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        if (gap > 6) return `Sprint ${ctx.sprintsDone}. You're ${gap} behind schedule. Catastrophic deficit. Start immediately.`;
                        return `Sprint done. ${gap} more. Time is not your friend here.`;
                    }
                ]
            },
            
            // TASK COMPLETION - Context: priority, sprintValue, tasksLeft
            taskComplete: {
                supportive: [
                    (ctx) => `Excellent! Task complete (+${ctx.sprintValue} sprint${ctx.sprintValue > 1 ? 's' : ''}). ${ctx.tasksLeft} more to go!`,
                    (ctx) => `Way to go! Another task checked off. You're making real progress.`,
                    (ctx) => `Task done! That's the kind of follow-through that gets results.`,
                    (ctx) => `Fantastic! Task finished. You're building momentum beautifully.`,
                    (ctx) => `Great execution! Task complete. ${ctx.tasksLeft} remaining on your list.`,
                    (ctx) => `Well done! That's another win. Keep this energy going!`,
                    (ctx) => `Task closed successfully. You're getting things done today!`
                ],
                balanced: [
                    (ctx) => `Task complete (+${ctx.sprintValue}). ${ctx.tasksLeft} remaining. Continue.`,
                    (ctx) => ctx.priority === 'high' ? `High-priority item complete. Progress acceptable.` : `Task closed. ${ctx.tasksLeft} remain.`,
                    (ctx) => `Item marked done. Sprint count updated. Next task.`,
                    (ctx) => `Task finished. ${ctx.tasksLeft} active items remain in queue.`,
                    (ctx) => `Work item closed. ${ctx.sprintValue} sprint${ctx.sprintValue > 1 ? 's' : ''} credited. Continue execution.`,
                    (ctx) => ctx.priority === 'high' ? `High-value work complete. Maintain focus on priorities.` : `Task complete. ${ctx.tasksLeft} pending.`,
                    (ctx) => `Item resolved. Sprint total updated. Proceed to next objective.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.priority === 'low') return `Low-priority task closed. Question: Why wasn't this delegated or eliminated? ${ctx.tasksLeft} real tasks remain.`;
                        if (ctx.priority === 'high' && ctx.sprintValue >= 3) return `High-value item complete (+${ctx.sprintValue} sprints). This is what winning looks like. Next.`;
                        return `Task done. ${ctx.tasksLeft} remain. Clock's running.`;
                    },
                    (ctx) => ctx.priority === 'high' ? `Finally. High-priority complete. Should have been done hours ago. ${ctx.tasksLeft} left.` : `Task closed. ${ctx.tasksLeft} items still require execution.`,
                    (ctx) => `One down. ${ctx.tasksLeft} to go. Execution speed insufficient. Accelerate.`,
                    (ctx) => {
                        if (ctx.priority === 'low') return `Low-priority complete. ${ctx.tasksLeft} items remain. Question priorities.`;
                        if (ctx.priority === 'high') return `High-priority closed. About time. ${ctx.tasksLeft} tasks pending.`;
                        return `Task done. ${ctx.tasksLeft} more. Speed inadequate.`;
                    },
                    (ctx) => ctx.priority === 'low' ? `Another low-priority task. ${ctx.tasksLeft} remain. Time allocation questionable.` : `Task complete. ${ctx.tasksLeft} left. Move faster.`,
                    (ctx) => `Task closed. ${ctx.tasksLeft} pending. Your pace puts completion at risk. Execute.`,
                    (ctx) => {
                        if (ctx.priority === 'high' && ctx.sprintValue >= 4) return `Major deliverable complete (+${ctx.sprintValue}). Exceptional work. More of this.`;
                        return `Task done. ${ctx.tasksLeft} remain. Current rate insufficient.`;
                    }
                ]
            },
            
            // INACTIVITY - Context: minutesIdle, sprintsDone, required
            inactivity: {
                supportive: [
                    (ctx) => `Hey there! You've been idle for a bit. Ready to tackle the next sprint?`,
                    (ctx) => `Taking a break? No problem! When you're ready, ${ctx.required - ctx.sprintsDone} sprint${ctx.required - ctx.sprintsDone !== 1 ? 's' : ''} await.`,
                    (ctx) => `Noticed some downtime. Whenever you're ready to continue, I'm here!`,
                    (ctx) => `Quick break? Totally fine! ${ctx.required - ctx.sprintsDone} sprints when you're refreshed.`,
                    (ctx) => `Taking a breather? Good self-care. Ready to resume when you are!`,
                    (ctx) => `No activity detected. Take your time! Work resumes when you're ready.`,
                    (ctx) => `Looks like a pause. ${ctx.required - ctx.sprintsDone} sprints waiting whenever you're set!`
                ],
                balanced: [
                    (ctx) => `Inactivity detected. ${ctx.required - ctx.sprintsDone} sprint${ctx.required - ctx.sprintsDone !== 1 ? 's' : ''} remaining.`,
                    (ctx) => `No progress for ${ctx.minutesIdle} minutes. Resume work when ready.`,
                    (ctx) => `Session paused. ${ctx.required - ctx.sprintsDone} sprints still required.`,
                    (ctx) => `Work stopped. ${ctx.required - ctx.sprintsDone} sprints pending completion.`,
                    (ctx) => `Idle period detected. Resume to maintain schedule.`,
                    (ctx) => `No activity logged. ${ctx.required - ctx.sprintsDone} sprint requirement unchanged.`,
                    (ctx) => `Extended pause. ${ctx.required - ctx.sprintsDone} sprints remain on today's target.`
                ],
                tough: [
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        if (gap > 6) return `${ctx.minutesIdle} minutes idle. You're ${gap} sprints behind. Every minute compounds the deficit. Move NOW.`;
                        if (gap > 4) return `Inactivity detected. ${gap} sprint${gap > 1 ? 's' : ''} remaining. Requirements don't negotiate. Execute.`;
                        return `Work stopped. Session still active. Either continue or end day.`;
                    },
                    (ctx) => `${ctx.minutesIdle}+ minutes wasted. ${ctx.required - ctx.sprintsDone} sprints won't complete themselves. Start now.`,
                    (ctx) => `Extended inactivity logged. Gap widening. Immediate action required.`,
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        if (gap > 5) return `Idle. ${gap} sprints behind. This is why deadlines get missed. Start immediately.`;
                        return `${ctx.minutesIdle} minutes gone. ${gap} sprints pending. Time doesn't pause for you.`;
                    },
                    (ctx) => `Inactivity period logged. ${ctx.required - ctx.sprintsDone} sprints still required. Delays unacceptable. Move.`,
                    (ctx) => `Work paused. ${ctx.required - ctx.sprintsDone} sprints remain. Your schedule is collapsing. Execute now.`,
                    (ctx) => {
                        const gap = ctx.required - ctx.sprintsDone;
                        return gap > 7 ? `CRITICAL: ${ctx.minutesIdle}min idle, ${gap} sprints behind. Complete failure trajectory. START NOW.` : `Idle too long. ${gap} remain. Execute.`;
                    }
                ]
            },
            
            // DISTRACTION PARKED - Context: distractionCount
            distractionParked: {
                supportive: [
                    (ctx) => `Distraction parked! Good job recognizing and capturing it.`,
                    (ctx) => `Nice catch! Distraction logged. Back to focused work.`,
                    (ctx) => `Distraction handled. You're staying on track!`,
                    (ctx) => `Well caught! Distraction captured. Refocus and continue.`,
                    (ctx) => `Great awareness! Distraction logged. Return to your task.`,
                    (ctx) => `Distraction noted. Good call capturing it for later!`,
                    (ctx) => `Nice save! Distraction parked. Back to your current focus.`
                ],
                balanced: [
                    (ctx) => `Distraction logged. Refocus on current work.`,
                    (ctx) => `Item parked. Return to sprint tasks.`,
                    (ctx) => ctx.distractionCount > 3 ? `Distraction #${ctx.distractionCount}. Pattern forming.` : `Distraction captured. Continue.`,
                    (ctx) => `Interruption logged. Resume primary work.`,
                    (ctx) => ctx.distractionCount > 4 ? `Distraction #${ctx.distractionCount} captured. Frequency notable.` : `Distraction parked. Refocus.`,
                    (ctx) => `Item noted for later. Return to active sprint.`,
                    (ctx) => `Distraction recorded. ${ctx.distractionCount} total today. Continue work.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.distractionCount > 7) return `Distraction #${ctx.distractionCount}. Pattern severe. Address root cause or accept failure.`;
                        if (ctx.distractionCount > 5) return `Distraction #${ctx.distractionCount} parked. Pattern detected. Address root cause or accept compromised output.`;
                        if (ctx.distractionCount > 2) return `Distraction logged (total: ${ctx.distractionCount}). Recurring interruptions signal environment or discipline issues.`;
                        return `Distraction parked. Refocus immediate.`;
                    },
                    (ctx) => `Another distraction (#${ctx.distractionCount}). Focus is a choice. Choose better.`,
                    (ctx) => ctx.distractionCount > 4 ? `Distraction epidemic. ${ctx.distractionCount} logged today. This is why you're behind.` : `Noted. Refocus now.`,
                    (ctx) => {
                        if (ctx.distractionCount > 6) return `${ctx.distractionCount} distractions today. Environment toxic or discipline absent. Fix this.`;
                        return `Distraction #${ctx.distractionCount}. Concentration broken. Refocus immediately.`;
                    },
                    (ctx) => ctx.distractionCount > 5 ? `Distraction ${ctx.distractionCount}. Pattern unmistakable. You're sabotaging your own work.` : `Distraction logged. Focus required.`,
                    (ctx) => `Another interruption (#${ctx.distractionCount}). Quality output requires sustained focus. Improve.`,
                    (ctx) => {
                        if (ctx.distractionCount > 8) return `CRITICAL: ${ctx.distractionCount} distractions. This is catastrophic for productivity. Address immediately.`;
                        return `Distraction ${ctx.distractionCount}. Each break costs 15+ minutes. Calculate the cost.`;
                    }
                ]
            },
            
            // SESSION START - Context: required
            sessionStart: {
                supportive: [
                    (ctx) => `Session started! ${ctx.required} sprint${ctx.required > 1 ? 's' : ''} planned for today. Let's make it a great day!`,
                    (ctx) => `Ready to go! Timer active. You've got this!`,
                    (ctx) => `Sprint underway! Stay focused and trust the process.`,
                    (ctx) => `Here we go! ${ctx.required} sprints on the agenda. You're going to crush this!`,
                    (ctx) => `Session active! Time to make progress. You're ready for this.`,
                    (ctx) => `Timer started! ${ctx.required} sprint${ctx.required > 1 ? 's' : ''} ahead. Let's do great work!`,
                    (ctx) => `Sprint beginning! Focus engaged. You've prepared well for this.`
                ],
                balanced: [
                    (ctx) => `Session active. ${ctx.required} sprint${ctx.required > 1 ? 's' : ''} required. Timer running.`,
                    (ctx) => `Sprint started. Focus mode engaged. Execute.`,
                    (ctx) => `Timer active. ${ctx.required} sprints on today's agenda.`,
                    (ctx) => `Work session initiated. ${ctx.required} sprint requirement. Begin execution.`,
                    (ctx) => `Sprint commenced. Timer running. ${ctx.required} sprints scheduled.`,
                    (ctx) => `Session launched. ${ctx.required} sprint target established. Proceed.`,
                    (ctx) => `Timer started. ${ctx.required} sprint${ctx.required > 1 ? 's' : ''} required. Execute tasks.`
                ],
                tough: [
                    (ctx) => `Session active. ${ctx.required} sprint${ctx.required > 1 ? 's' : ''} required today. Timer running. Execute.`,
                    (ctx) => `Sprint started. ${ctx.required} sprint requirement locked. No excuses. Perform.`,
                    (ctx) => `FOCUS MODE: ${ctx.required} sprints required. Timer running. Results expected.`,
                    (ctx) => `Session initiated. ${ctx.required} sprint minimum. Failure not an option. Execute now.`,
                    (ctx) => `Timer active. ${ctx.required} sprints required. Your performance is being measured. Deliver.`,
                    (ctx) => `Sprint started. ${ctx.required} sprint target established. Excuses irrelevant. Execute.`,
                    (ctx) => `Session launched. ${ctx.required} sprint requirement. This is your job. Perform.`
                ]
            },
            
            // TASK MOVED - Context: toBucket, fromBucket
            taskMoved: {
                supportive: [
                    (ctx) => ctx.toBucket === 'strategic' ? `Great prioritization! Moved to Strategic.` : `Task reclassified. Nice organization!`,
                    (ctx) => `Task moved successfully. You're staying organized!`,
                    (ctx) => `Good call on the priority adjustment!`,
                    (ctx) => `Nice organizational move! Task reclassified appropriately.`,
                    (ctx) => ctx.toBucket === 'deepwork' ? `Perfect! Deep Work bucket is for focused tasks.` : `Task moved. Good priority management!`,
                    (ctx) => `Excellent categorization! Task properly classified.`,
                    (ctx) => `Smart move! Task priority adjusted well.`
                ],
                balanced: [
                    (ctx) => `Task moved to ${ctx.toBucket.toUpperCase()}. Priority updated.`,
                    (ctx) => `Reclassification complete. Continue.`,
                    (ctx) => `Task priority adjusted.`,
                    (ctx) => `Item moved from ${ctx.fromBucket.toUpperCase()} to ${ctx.toBucket.toUpperCase()}.`,
                    (ctx) => `Task categorization updated. Priority reflects new placement.`,
                    (ctx) => `Classification change logged. Proceed.`,
                    (ctx) => `Task bucket reassigned. Priority modified accordingly.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.toBucket === 'strategic') return `Task moved to STRATEGIC. Good. High-value work gets priority.`;
                        if (ctx.toBucket === 'admin' && ctx.fromBucket === 'strategic') return `Task downgraded to ADMIN. Question: Was this ever truly strategic?`;
                        return `Task reclassified to ${ctx.toBucket.toUpperCase()}. Ensure alignment with objectives.`;
                    },
                    (ctx) => ctx.toBucket === 'strategic' ? `Finally. Strategic work identified. Should have been there from the start.` : `Task moved. Priority reassessed.`,
                    (ctx) => `Reclassification logged. Better late than never.`,
                    (ctx) => {
                        if (ctx.toBucket === 'admin' && ctx.fromBucket === 'deepwork') return `DEEP WORK ‚Üí ADMIN. Prioritization failure. This should have been obvious.`;
                        if (ctx.toBucket === 'strategic') return `Moved to STRATEGIC. Correct placement. High-value focus required.`;
                        return `Task moved to ${ctx.toBucket.toUpperCase()}. Validate priority logic.`;
                    },
                    (ctx) => `Priority adjusted. ${ctx.toBucket === 'strategic' ? 'High-value focus appropriate.' : 'Confirm this is correct classification.'}`,
                    (ctx) => `Task reclassified from ${ctx.fromBucket.toUpperCase()} to ${ctx.toBucket.toUpperCase()}. Question: Why wasn't this right initially?`,
                    (ctx) => ctx.toBucket === 'admin' ? `Task demoted to ADMIN. Low-value work identified. Consider delegation.` : `Reclassification complete.`
                ]
            },
            
            // SPRINT ADJUSTED - Context: newSprints, oldSprints, totalRequired
            sprintAdjusted: {
                supportive: [
                    (ctx) => ctx.newSprints > ctx.oldSprints ? `Sprint estimate increased. You're being thorough - that's smart!` : `Sprint estimate reduced. Nice efficiency!`,
                    (ctx) => `Estimate updated to ${ctx.newSprints} sprints. Total required: ${ctx.totalRequired}.`,
                    (ctx) => `Good adjustment! Total now ${ctx.totalRequired} sprints.`,
                    (ctx) => ctx.newSprints > ctx.oldSprints ? `Increased to ${ctx.newSprints} sprints. Good catch on the complexity!` : `Reduced to ${ctx.newSprints}. Great efficiency!`,
                    (ctx) => `Sprint value adjusted. You're managing scope well!`,
                    (ctx) => `Updated to ${ctx.newSprints} sprints. Total target: ${ctx.totalRequired}.`,
                    (ctx) => `Nice adjustment! Task properly estimated now.`
                ],
                balanced: [
                    (ctx) => `Sprint estimate: ${ctx.oldSprints} ‚Üí ${ctx.newSprints}. Total required: ${ctx.totalRequired}.`,
                    (ctx) => ctx.newSprints > ctx.oldSprints ? `Estimate increased. Total: ${ctx.totalRequired}.` : `Estimate reduced. Total: ${ctx.totalRequired}.`,
                    (ctx) => `Sprint count adjusted. Requirements updated.`,
                    (ctx) => `Task estimate modified: ${ctx.oldSprints} to ${ctx.newSprints} sprints. Total: ${ctx.totalRequired}.`,
                    (ctx) => `Sprint value changed. Total requirement now ${ctx.totalRequired}.`,
                    (ctx) => `Estimate adjustment logged. New total: ${ctx.totalRequired} sprints.`,
                    (ctx) => `Sprint requirement updated. ${ctx.newSprints} sprints now allocated.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.newSprints > ctx.oldSprints) return `Sprint requirement increased to ${ctx.newSprints}. Total required now: ${ctx.totalRequired}. Adjust expectations accordingly.`;
                        return `Sprint estimate reduced. Was initial assessment inflated?`;
                    },
                    (ctx) => ctx.newSprints > ctx.oldSprints ? `Scope creep detected. ${ctx.newSprints} sprints now required. This is why projects fail.` : `Estimate decreased. Should have been right the first time.`,
                    (ctx) => `Sprint value changed to ${ctx.newSprints}. Total required: ${ctx.totalRequired}. Plan better.`,
                    (ctx) => {
                        if (ctx.newSprints > ctx.oldSprints) return `Estimate inflated from ${ctx.oldSprints} to ${ctx.newSprints}. Total now ${ctx.totalRequired}. Poor initial scoping.`;
                        return `Reduced to ${ctx.newSprints}. Initial estimate was wrong. Improve estimation accuracy.`;
                    },
                    (ctx) => ctx.newSprints > ctx.oldSprints ? `Sprint count increased. ${ctx.totalRequired} total required. Lack of planning evident.` : `Estimate cut. Question: Was this task ever understood?`,
                    (ctx) => `Adjustment: ${ctx.oldSprints} ‚Üí ${ctx.newSprints}. Total: ${ctx.totalRequired}. ${ctx.newSprints > ctx.oldSprints ? 'Scope control failure.' : 'Initial estimate questionable.'}`,
                    (ctx) => {
                        if (ctx.newSprints > ctx.oldSprints && ctx.newSprints - ctx.oldSprints > 2) return `Major increase: ${ctx.oldSprints} ‚Üí ${ctx.newSprints}. Total ${ctx.totalRequired}. This is mismanagement.`;
                        return `Sprint modified to ${ctx.newSprints}. Total: ${ctx.totalRequired}. Estimate correctly from the start.`;
                    }
                ]
            },
            
            // DEFAULT IDLE STATE - Context: gap (required - done)
            idleState: {
                supportive: [
                    (ctx) => ctx.gap > 0 ? `Ready when you are! ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} remaining today.` : `You've completed today's requirements! Additional work is optional.`,
                    (ctx) => `System idle. Start a sprint whenever you're ready!`,
                    (ctx) => ctx.gap > 2 ? `${ctx.gap} sprints left. You can do this!` : `Almost there! ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} to go.`,
                    (ctx) => ctx.gap > 0 ? `${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} remaining. Begin when you're ready!` : `Requirements met! Excellent work today.`,
                    (ctx) => `System ready. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} on your schedule. Start when set!`,
                    (ctx) => ctx.gap > 3 ? `${ctx.gap} sprints ahead. You've got plenty of time!` : `Just ${ctx.gap} more! You're so close!`,
                    (ctx) => ctx.gap === 0 ? `Target achieved! Consider additional work or enjoy your success.` : `System idle. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} waiting.`
                ],
                balanced: [
                    (ctx) => ctx.gap > 0 ? `System idle. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} remaining. Start when ready.` : `Requirements met. Additional work optional.`,
                    (ctx) => `Session paused. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} required.`,
                    (ctx) => `Idle. Start next sprint to continue progress.`,
                    (ctx) => ctx.gap > 0 ? `No active sprint. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} pending.` : `Daily target reached. Proceed as needed.`,
                    (ctx) => `System idle. ${ctx.gap} sprint requirement unchanged.`,
                    (ctx) => `Awaiting input. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} remain in queue.`,
                    (ctx) => ctx.gap === 0 ? `Sprint requirement fulfilled. Continue working optional.` : `Idle mode. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} scheduled.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.gap > 5) return `IDLE: ${ctx.gap} sprints behind. Start next sprint NOW. Every second matters.`;
                        if (ctx.gap > 2) return `${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} remaining. No time to waste. Move.`;
                        if (ctx.gap > 0) return `${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} left. Idle unacceptable. Execute.`;
                        return `Requirements met. Additional work optional.`;
                    },
                    (ctx) => ctx.gap > 0 ? `Idle state unacceptable. ${ctx.gap} sprints required. Execute immediately.` : `Day complete. Reassess if more work warranted.`,
                    (ctx) => ctx.gap > 3 ? `System idle. You're ${ctx.gap} sprints behind. Every second counts. START NOW.` : `${ctx.gap} left. Start now.`,
                    (ctx) => {
                        if (ctx.gap > 4) return `CRITICAL IDLE: ${ctx.gap} sprints behind schedule. Failure trajectory. Execute immediately.`;
                        if (ctx.gap > 1) return `${ctx.gap} sprints pending. Idle time unacceptable. Move.`;
                        return ctx.gap === 1 ? `One sprint remains. Finish it. No excuses.` : `Target met. Assess next actions.`;
                    },
                    (ctx) => ctx.gap > 0 ? `Idle. ${ctx.gap} sprint${ctx.gap !== 1 ? 's' : ''} required. Your performance depends on starting NOW.` : `Requirements complete. Additional work discretionary.`,
                    (ctx) => {
                        if (ctx.gap > 6) return `SEVERE: ${ctx.gap} sprints behind. Complete project failure imminent. START IMMEDIATELY.`;
                        return ctx.gap > 0 ? `${ctx.gap} sprints remain. Delays compound. Execute now.` : `Day complete. Plan tomorrow.`;
                    },
                    (ctx) => ctx.gap > 2 ? `Idle unacceptable. ${ctx.gap} sprints outstanding. This is why deadlines slip. Execute.` : ctx.gap > 0 ? `${ctx.gap} remain. Start now.` : `Complete.`
                ]
            },
            
            // RESUME FROM MEETING - Context: required
            resumeFromMeeting: {
                supportive: [
                    (ctx) => `Welcome back! Meeting done. ${ctx.required} sprints needed today. You've got this!`,
                    (ctx) => `Meeting complete! Ready to refocus? ${ctx.required} sprints on your schedule.`,
                    (ctx) => `Back from the meeting! Let's get some work done. ${ctx.required} sprints await.`,
                    (ctx) => `Meeting wrapped! Time to shift back into execution mode. ${ctx.required} sprints needed.`,
                    (ctx) => `Welcome back! Meeting over. ${ctx.required} sprints remaining. Let's make progress!`
                ],
                balanced: [
                    (ctx) => `Meeting complete. Resume work. ${ctx.required} sprints required.`,
                    (ctx) => `Meeting mode disabled. ${ctx.required} sprint${ctx.required !== 1 ? 's' : ''} pending.`,
                    (ctx) => `Back to execution. ${ctx.required} sprints on schedule.`,
                    (ctx) => `Meeting concluded. Sprint timer reactivated. ${ctx.required} required.`,
                    (ctx) => `Resume work mode. ${ctx.required} sprint${ctx.required !== 1 ? 's' : ''} remain.`
                ],
                tough: [
                    (ctx) => ctx.required > 8 ? `Meeting done. ${ctx.required} sprints still required. Time wasted in meeting room. Execute NOW.` : `Meeting complete. ${ctx.required} sprints. Make up lost time. START.`,
                    (ctx) => `Back from meeting. ${ctx.required} sprints outstanding. Clock didn't stop. Execute immediately.`,
                    (ctx) => ctx.required > 10 ? `Meeting over. ${ctx.required} sprints required. Time deficit severe. Immediate execution mandatory.` : `Meeting done. ${ctx.required} sprints. Lost time can't be recovered. Move.`,
                    (ctx) => `Meeting finished. ${ctx.required} sprints remain. Meeting time is gone. Sprint time is now. Execute.`,
                    (ctx) => ctx.required > 6 ? `Back to work. ${ctx.required} sprints outstanding. Every meeting minute compounded your gap. START NOW.` : `Meeting complete. ${ctx.required} sprints. Execute.`
                ]
            },
            
            // PRIORITY MISALIGNMENT (V20.6) - Context: lowEnergyCount
            priorityMismatch: {
                supportive: [
                    (ctx) => `You've been choosing easier modes while important work is waiting. When you're ready, try tackling the high-priority items.`,
                    (ctx) => `I notice you're selecting low-energy modes repeatedly. The challenging work might benefit from more energy.`,
                    (ctx) => `You've taken the easy path a few times. Consider whether you're ready to tackle something bigger.`
                ],
                balanced: [
                    (ctx) => `Pattern detected: Low-energy selections with high-priority work pending. Consider your approach.`,
                    (ctx) => `Multiple low-energy choices. High-priority items need attention at some point.`,
                    (ctx) => `Low-energy mode selected ${ctx.lowEnergyCount} times. High-priority work remains.`
                ],
                tough: [
                    (ctx) => `You keep choosing easy modes. High-priority work doesn't complete itself.`,
                    (ctx) => `Avoidance pattern: ${ctx.lowEnergyCount} low-energy selections. Hard work is still there.`,
                    (ctx) => `You're selecting comfort over challenge. The difficult work is what moves things forward.`
                ]
            },
            
            // BREAK DENIAL (V20.6 ENHANCED) - Context: focusTime, breakAttempts
            // Tough love at core for all levels - delivery differs
            breakDenied: {
                supportive: [
                    (ctx) => {
                        if (ctx.sessionJustStarted) {
                            return `Hey, I see you just opened the app ${ctx.minutesSinceLastAction} minutes ago. I know it's tempting to ease in, but starting with work builds better momentum than starting with a break. Trust me on this one.`;
                        } else if (ctx.todayFocusTime > 60) {
                            return `You've already done ${ctx.todayFocusTime} minutes today‚Äîsolid work. That said, this particular session hasn't started yet. One sprint, then break properly.`;
                        } else {
                            return `I know the resistance is strong right now. That's normal. But taking a break before you've done anything just makes the resistance stronger when you come back. Let's try one quick sprint first.`;
                        }
                    },
                    (ctx) => {
                        if (ctx.focusTime === 0) {
                            return `Breaks hit different after you've actually worked. Your brain literally rewards you more when rest is earned. Try 15 minutes first‚Äîyou'll feel the difference.`;
                        } else {
                            return `You might really need this break‚ÄîI get that. But I've noticed breaks feel more restorative when they follow even 15 minutes of focus. Worth trying?`;
                        }
                    },
                    (ctx) => {
                        const breakAttempts = ctx.breakAttempts || 0;
                        if (breakAttempts > 2) {
                            return `Third break attempt without focus. I get it‚Äîresistance is real. But avoiding doesn't make it easier. One sprint makes the break feel earned.`;
                        } else {
                            return `You might find the break more refreshing if you complete some work first. Rest follows effort‚Äîthat's when it actually restores you.`;
                        }
                    }
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.focusTime === 0 && ctx.yesterdayFocusTime > 0) {
                            return `You did ${ctx.yesterdayFocusTime} minutes yesterday. Today: zero. Give me one sprint, then break. Your pattern matters.`;
                        } else if (ctx.minutesSinceLastAction < 10) {
                            return `${ctx.minutesSinceLastAction} minutes in and trying to break? Not quite time yet. Your brain performs better with momentum‚Äîstart a sprint first.`;
                        } else {
                            return `Insufficient focus time logged. Breaks work better psychologically when they follow effort. Try ${ctx.focusTime === 0 ? '15' : '10'} more minutes.`;
                        }
                    },
                    (ctx) => {
                        const breakAttempts = ctx.breakAttempts || 0;
                        if (breakAttempts > 2) {
                            return `Third break attempt. I know starting is hard, but you need at least one sprint under your belt. The avoidance pattern only makes it worse.`;
                        } else {
                            return `Break timing: Better after focus sessions. Current focus: ${ctx.focusTime} min. That's not enough to earn rest yet.`;
                        }
                    },
                    (ctx) => `Breaks work better after sustained focus. Complete a sprint‚Äîthen the break actually feels like rest instead of procrastination.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.minutesSinceLastAction < 5) {
                            return `You literally just sat down ${ctx.minutesSinceLastAction} minutes ago. Work first, break later. That's how this works.`;
                        } else if (ctx.minutesSinceLastAction < 15 && ctx.focusTime === 0) {
                            return `${ctx.minutesSinceLastAction} minutes in and already want a break? You haven't done anything yet. Start working.`;
                        } else {
                            return `Zero focus time today. Breaks are earned through work. You want rest? Earn it first.`;
                        }
                    },
                    (ctx) => {
                        const timeOfDay = ctx.timeOfDay || new Date().getHours();
                        if (timeOfDay < 10 && ctx.focusTime === 0) {
                            return `You just woke up and want a break already? Coffee, then work. Breaks come after effort.`;
                        } else if (timeOfDay > 20 && ctx.focusTime === 0) {
                            return `Late start and trying to break immediately? Focus first, then rest. Otherwise go to bed.`;
                        } else {
                            return `No work logged. Breaks follow effort, not precede it. This is backwards.`;
                        }
                    },
                    (ctx) => {
                        const breakAttempts = ctx.breakAttempts || 0;
                        if (breakAttempts >= 3) {
                            return `This is the third time you've tried to break without working today. The pattern is clear: You're avoiding work. Call it what it is.`;
                        } else {
                            return `You're trying to break without working. That's not how productive days happen. Execute first.`;
                        }
                    }
                ]
            },
            
            // EXCESSIVE BREAKS (V20.6 ENHANCED) - Context: consecutiveBreaks, focusBreakRatio
            // Time-aware, pattern recognition, direct
            excessiveBreaks: {
                supportive: [
                    (ctx) => {
                        if (ctx.todayBreakTime && ctx.todayFocusTime) {
                            return `You've taken ${ctx.todayBreakTime} minutes of breaks and ${ctx.todayFocusTime} minutes of focus today. When you're ready, let's shift that balance toward more focus time.`;
                        } else {
                            return `You've taken several breaks recently. Your work will benefit from some sustained attention now.`;
                        }
                    },
                    (ctx) => `Multiple breaks taken. Consider balancing with a longer focus session‚Äîyour output will improve and you'll feel better about the rest.`,
                    (ctx) => `Break time is outweighing work time. I know extended focus is hard, but it's where the real progress happens.`
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.todayBreakTime && ctx.todayFocusTime) {
                            const ratio = (ctx.todayFocusTime / ctx.todayBreakTime).toFixed(1);
                            return `Today: ${ctx.todayFocusTime}min focus, ${ctx.todayBreakTime}min breaks. Ratio: ${ratio}:1. For productivity, aim for at least 3:1.`;
                        } else {
                            return `${ctx.consecutiveBreaks} consecutive breaks. Focus:break ratio needs adjustment for meaningful output.`;
                        }
                    },
                    (ctx) => `Break frequency high. Multiple breaks without equivalent focus limits what you can accomplish. Consider your pattern.`,
                    (ctx) => `Multiple breaks logged. Output requires focused time blocks, not fragmented attention. Balance needs correction.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.todayBreakTime && ctx.todayFocusTime) {
                            return `Real talk: ${ctx.todayBreakTime} minutes on breaks, ${ctx.todayFocusTime} minutes working today. That ratio doesn't build anything.`;
                        } else {
                            return `${ctx.consecutiveBreaks} breaks without sustained focus. This pattern limits results. Work requires work, not rest.`;
                        }
                    },
                    (ctx) => {
                        if (ctx.consecutiveBreaks >= 3) {
                            return `This is your third break in a row. At some point you need to admit you're avoiding work. That's fine‚Äîbut call it what it is.`;
                        } else {
                            return `You're breaking more than working. This pattern guarantees you'll feel unproductive tonight.`;
                        }
                    },
                    (ctx) => {
                        const timeBetweenBreaks = ctx.timeBetweenBreaks || 0;
                        if (timeBetweenBreaks > 0 && timeBetweenBreaks < 20) {
                            return `${timeBetweenBreaks} minutes between breaks. You're pacing the room instead of working. Sit down and focus.`;
                        } else {
                            return `Fourth break. Each one makes the next sprint harder to start. This avoidance pattern has diminishing returns.`;
                        }
                    }
                ]
            },
            
            // IDLE WITHOUT DECISION (V20.6 ENHANCED) - Context: idleMinutes
            // Direct, time-aware, calls out indecision
            idleInterruption: {
                supportive: [
                    (ctx) => {
                        if (ctx.idleMinutes > 20) {
                            return `You've been paused for ${ctx.idleMinutes} minutes. That's a long time to be undecided. When you're ready, pick something‚Äîfocus, break, or close the app.`;
                        } else {
                            return `You've been paused for a while. No rush, but staying in limbo uses mental energy. Make a choice when ready.`;
                        }
                    },
                    (ctx) => `No activity for ${ctx.idleMinutes} minutes. Take your time deciding, but remember: indecision is its own form of stress.`,
                    (ctx) => `Extended pause noticed. Whatever you choose‚Äîwork, break, or stepping away‚Äîis fine. Just choose something.`
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.idleMinutes > 25) {
                            return `Idle for ${ctx.idleMinutes} minutes. The longer you sit undecided, the harder it gets to start anything. Choose: focus, break, or close.`;
                        } else {
                            return `Idle for ${ctx.idleMinutes} minutes. Indecision burns energy. Select your next action.`;
                        }
                    },
                    (ctx) => `No activity detected. Time to choose: focus, break, or wrap up. Limbo doesn't serve you.`,
                    (ctx) => `Extended idle period. Make a decision‚Äîsitting here thinking about it achieves nothing.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.idleMinutes > 30) {
                            return `You've been staring at this screen for ${ctx.idleMinutes} minutes. Make a decision: work, break, or close the app. Indecision is its own form of avoidance.`;
                        } else if (ctx.idleMinutes > 15) {
                            return `${ctx.idleMinutes} minutes of nothing. The longer you sit here undecided, the harder it gets to start. Pick something.`;
                        } else {
                            return `${ctx.idleMinutes} minutes idle. You're burning mental energy deciding instead of doing. Choose now.`;
                        }
                    },
                    (ctx) => {
                        const timeOfDay = ctx.timeOfDay || new Date().getHours();
                        if (timeOfDay >= 22) {
                            return `It's after ${timeOfDay}:00 and you've been idle for ${ctx.idleMinutes} minutes. Either commit to working or go to bed. This limbo helps nobody.`;
                        } else {
                            return `Idle time is wasted time. Either start working or close the app. Sitting here "thinking about it" achieves nothing.`;
                        }
                    },
                    (ctx) => `${ctx.idleMinutes} minutes idle. Time doesn't pause while you decide. Make a choice or accept that you're avoiding.`
                ]
            },
            
            // START/STOP PATTERN (V20.6 ENHANCED) - Context: abortCount
            // Empathetic but firm, identifies root causes
            avoidancePattern: {
                supportive: [
                    (ctx) => {
                        if (ctx.abortCount >= 4) {
                            return `You keep starting and stopping (${ctx.abortCount} times). That's often a sign the task feels overwhelming. What's actually getting in the way? Can we break it smaller?`;
                        } else {
                            return `You keep starting and stopping. That's often a sign something feels challenging. Let's try committing to just one full sprint‚Äîeven if it's 15 minutes.`;
                        }
                    },
                    (ctx) => `Multiple starts without completion. Pattern noticed: Starting but not finishing. Consider what's making it hard to continue‚Äîis the task too big?`,
                    (ctx) => {
                        const avgAbortTime = ctx.avgTimeBeforeAbort || 5;
                        return `You tend to stop around the ${avgAbortTime}-minute mark. That's when initial discomfort kicks in. The work doesn't get easier by restarting‚Äîtry pushing through once.`;
                    }
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.abortCount >= 5) {
                            return `This is the ${ctx.abortCount}th time you've started without finishing today. Something's blocking you‚Äîand avoiding it won't make it easier. What's actually going on?`;
                        } else {
                            return `${ctx.abortCount} incomplete attempts. This pattern suggests avoidance. The task isn't getting easier by circling it.`;
                        }
                    },
                    (ctx) => {
                        return `You keep starting then stopping. That usually means the task feels overwhelming. Try breaking it down smaller‚Äîlike, embarrassingly small. Just do one tiny piece.`;
                    },
                    (ctx) => {
                        const avgTimeBeforeAbort = ctx.avgTimeBeforeAbort || 5;
                        return `You abort around the ${avgTimeBeforeAbort}-minute mark consistently. That's when discomfort kicks in. The work doesn't get easier by restarting‚Äîyou just reset the discomfort timer.`;
                    }
                ],
                tough: [
                    (ctx) => {
                        if (ctx.abortCount >= 5) {
                            return `${ctx.abortCount} starts. Zero completions. This is textbook avoidance behavior. The pattern is clear‚Äîyou're circling the work instead of doing it.`;
                        } else {
                            return `${ctx.abortCount} starts without finishing. You keep restarting when it gets uncomfortable. That pattern prevents any real progress.`;
                        }
                    },
                    (ctx) => `You keep starting without finishing. Each restart makes the next attempt harder. The avoidance pattern compounds. Complete one sprint.`,
                    (ctx) => {
                        const avgAbortTime = ctx.avgTimeBeforeAbort || 5;
                        return `Multiple aborts at the ${avgAbortTime}-minute mark. You quit exactly when real work starts. That's where growth happens‚Äîand you're avoiding it.`;
                    }
                ]
            },
            
            // DISCOMFORT ABORT (V20.6 ENHANCED) - Context: timeBeforeAbort
            // Identifies resistance points, encourages push-through
            discomfortQuit: {
                supportive: [
                    (ctx) => {
                        if (ctx.timeBeforeAbort < 10) {
                            return `Sprint ended at ${ctx.timeBeforeAbort} minutes. That's exactly when the initial discomfort starts‚Äîbut also when the value begins. Want to try pushing to 15 next time?`;
                        } else {
                            return `Stopped at ${ctx.timeBeforeAbort} minutes. Often that's a common resistance point. The discomfort usually passes if you push through it.`;
                        }
                    },
                    (ctx) => `Quick exit noticed at ${ctx.timeBeforeAbort} minutes. The initial resistance is normal‚Äîit usually fades around minute 10-12. Consider staying longer next time.`,
                    (ctx) => `Sprint ended early. That's often when the discomfort starts but the productive phase begins. The breakthrough comes after the resistance.`
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.timeBeforeAbort < 8) {
                            return `Sprint terminated at ${ctx.timeBeforeAbort} minutes. That's before you hit flow state. Discomfort is part of the process‚Äîit signals the brain is engaging.`;
                        } else {
                            return `Early exit from focus at ${ctx.timeBeforeAbort} minutes. The discomfort phase is where adaptation happens. Pushing through builds capacity.`;
                        }
                    },
                    (ctx) => `Stopped when difficulty increased (${ctx.timeBeforeAbort} min). This pattern limits how deep you can go. Flow state requires getting past initial resistance.`,
                    (ctx) => `Sprint ended at ${ctx.timeBeforeAbort} minutes. The resistance point. Real work starts after discomfort, not before it.`
                ],
                tough: [
                    (ctx) => {
                        if (ctx.timeBeforeAbort < 10) {
                            return `Quit at ${ctx.timeBeforeAbort} minutes. That's exactly when real work starts. You're stopping at the threshold of productivity.`;
                        } else {
                            return `Terminated at ${ctx.timeBeforeAbort} minutes‚Äîright when it got uncomfortable. That's where growth happens. You're avoiding the productive phase.`;
                        }
                    },
                    (ctx) => `You exit when it gets uncomfortable. That's where actual work happens. Quitting at discomfort guarantees you never reach deep focus.`,
                    (ctx) => {
                        const avgAbortTime = ctx.avgTimeBeforeAbort || ctx.timeBeforeAbort;
                        return `Early termination at ${ctx.timeBeforeAbort} minutes. Your pattern: quit at ~${avgAbortTime} min when resistance appears. That's the exact moment to continue, not stop.`;
                    }
                ]
            },
            
            // CLEAN EXIT PROMPT (V20.6) - Context: refusalCount
            cleanExit: {
                supportive: [
                    (ctx) => `It seems like this might not be the right time to work. That's completely okay. You can step away and return when you're ready.`,
                    (ctx) => `You've resisted several times. Maybe it's better to pause and try again later when conditions are better.`,
                    (ctx) => `Sometimes it's not the right moment. No judgment. Come back when you feel more prepared.`
                ],
                balanced: [
                    (ctx) => `Pattern suggests this isn't an effective work session. Consider whether to continue or reschedule.`,
                    (ctx) => `${ctx.refusalCount} avoidance signals. Evaluate if now is the right time.`,
                    (ctx) => `Work resistance detected. Sometimes stepping away is the better choice.`
                ],
                tough: [
                    (ctx) => `Multiple refusals detected. You're not engaging. Consider whether you should be here.`,
                    (ctx) => `${ctx.refusalCount} avoidances. Session isn't productive. Reassess timing.`,
                    (ctx) => `You're resisting consistently. This session isn't working.`
                ]
            },
            
            // ============================================
            // STUDENT-SPECIFIC COACHING (SESSION-BASED)
            // ============================================
            
            // STUDY SESSION START - Context: sessionNumber, timeOfDay, hoursSinceLastSession
            studySessionStart: {
                supportive: [
                    (ctx) => {
                        if (ctx.sessionNumber === 1) {
                            return `First study session of the day. Starting is the hardest part, and you just did it. Now let's make it productive.`;
                        } else if (ctx.sessionNumber >= 3) {
                            return `Session ${ctx.sessionNumber} today‚Äîyou're building a solid study day. Remember: progress over perfection.`;
                        } else {
                            return `Another study session. You're showing up. That matters. Let's make this one count.`;
                        }
                    }
                ],
                balanced: [
                    (ctx) => {
                        const hoursSince = ctx.hoursSinceLastSession || 0;
                        if (hoursSince > 24) {
                            return `First session in ${Math.floor(hoursSince)}+ hours. Long gap. Let's rebuild momentum‚Äîstart with something manageable.`;
                        } else if (ctx.timeOfDay >= 22) {
                            return `Late-night session (${ctx.timeOfDay}:00). Your focus will fade faster. Plan for shorter sprints with more breaks.`;
                        } else {
                            return `Study session ${ctx.sessionNumber} starting. Set an intention: what's the one thing you need to accomplish?`;
                        }
                    }
                ],
                tough: [
                    (ctx) => {
                        if (ctx.sessionNumber === 1 && ctx.timeOfDay > 15) {
                            return `First session and it's after 3pm. Late start, but you're here. No excuses now‚Äîmake this count.`;
                        } else if (ctx.sessionNumber >= 3) {
                            return `Third study session today. Your classmates are on Netflix. You're choosing different. Don't waste this momentum.`;
                        } else if (ctx.lastSessionAborted) {
                            return `Last session: started strong, quit early. This time: finish what you start.`;
                        } else {
                            return `Let's go. Phone face-down, distractions off. You know what needs to happen.`;
                        }
                    }
                ]
            },
            
            // LATE NIGHT CHECK - Context: timeOfDay, sessionMinutes, todaySessionCount
            lateNightStudy: {
                supportive: [
                    (ctx) => {
                        if (ctx.timeOfDay >= 23) {
                            return `It's late (${ctx.timeOfDay}:00). Your focus won't be as sharp as daytime. Be kind to yourself‚Äîshorter sprints are fine. Or consider if sleep would serve you better.`;
                        } else {
                            return `Late evening session. Your brain is tired. Quality over quantity tonight.`;
                        }
                    }
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.timeOfDay >= 22 && ctx.todaySessionCount === 1) {
                            return `Late-night session and it's your only one today. If this is crisis mode, make every minute count. If you're just procrastinating sleep, consider starting fresh tomorrow.`;
                        } else {
                            return `Late session (${ctx.timeOfDay}:00). If you're genuinely productive, great. If this is guilt-studying, sleep might be smarter.`;
                        }
                    }
                ],
                tough: [
                    (ctx) => {
                        if (ctx.timeOfDay >= 23 && ctx.sessionMinutes < 30) {
                            return `It's past 11pm and you've studied ${ctx.sessionMinutes} minutes. If you're pulling an all-nighter, commit. If not, go to sleep and study effectively tomorrow.`;
                        } else if (ctx.timeOfDay >= 1 && ctx.timeOfDay < 5) {
                            return `It's ${ctx.timeOfDay}am. Real question: is this productive studying or guilt-driven busywork? Sometimes sleep is the better choice.`;
                        } else {
                            return `Late night studying. Your retention is lower than daytime. This better be exam prep, not procrastination.`;
                        }
                    }
                ]
            },
            
            // LONG GAP BETWEEN SESSIONS - Context: hoursSinceLastSession
            sessionGap: {
                supportive: [
                    (ctx) => {
                        if (ctx.hoursSinceLastSession > 48) {
                            return `It's been ${Math.floor(ctx.hoursSinceLastSession / 24)} days. Long break. No judgment‚Äîjust notice that consistency helps momentum. Welcome back.`;
                        } else {
                            return `${Math.floor(ctx.hoursSinceLastSession)} hours since last session. That's okay. You're here now. Let's use this time well.`;
                        }
                    }
                ],
                balanced: [
                    (ctx) => {
                        if (ctx.hoursSinceLastSession > 36) {
                            return `${Math.floor(ctx.hoursSinceLastSession)} hours since last session. Extended gaps make restarting harder. Try to maintain rhythm.`;
                        } else {
                            return `${Math.floor(ctx.hoursSinceLastSession)}h gap since last session. Consistency builds momentum. Keep that in mind.`;
                        }
                    }
                ],
                tough: [
                    (ctx) => {
                        if (ctx.hoursSinceLastSession > 48) {
                            return `First session in ${Math.floor(ctx.hoursSinceLastSession / 24)} days. That gap is a problem. Consistency beats intensity.`;
                        } else if (ctx.hoursSinceLastSession > 24) {
                            return `24+ hour gap since last session. Long breaks kill momentum. You know this. Fix the pattern.`;
                        } else {
                            return `${Math.floor(ctx.hoursSinceLastSession)}h gap. Every long gap makes the next start harder.`;
                        }
                    }
                ]
            }
        };
        
        // Get AI message based on intensity mode and context
        function getAICoachMessage(category, context = {}) {
            const mode = state.currentMode || 'balanced';
            
            // STUDENT MODE: Use student-specific messages where available
            if (state.sessionMode && aiCoachLibrary[`student${category.charAt(0).toUpperCase() + category.slice(1)}`]) {
                // Try student version first (e.g., 'studySessionStart' instead of 'sessionStart')
                const studentCategory = `student${category.charAt(0).toUpperCase() + category.slice(1)}`;
                const studentMessages = aiCoachLibrary[studentCategory]?.[mode];
                if (studentMessages) {
                    const message = studentMessages[Math.floor(Math.random() * studentMessages.length)];
                    const enhancedCtx = getEnhancedContext(context);
                    return typeof message === 'function' ? message(enhancedCtx) : message;
                }
            }
            
            // Use regular messages
            const messages = aiCoachLibrary[category]?.[mode];
            
            if (!messages) return 'System operational.';
            
            // Enhance context with time awareness and pattern recognition
            const enhancedCtx = getEnhancedContext(context);
            
            // Pick random message from array
            const message = messages[Math.floor(Math.random() * messages.length)];
            
            // If message is function, call with enhanced context; otherwise return string
            return typeof message === 'function' ? message(enhancedCtx) : message;
        }
        
        // Check if user is focusing on low priority items
        function checkPriorityAlignment() {
            let lowPriorityCount = 0;
            let highPriorityCount = 0;
            
            ['admin', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    if (!task.completed) {
                        if (task.priority === 'low') lowPriorityCount++;
                        if (task.priority === 'high') highPriorityCount++;
                    }
                });
            });
            
            // If mostly low priority items in active buckets, alert
            if (lowPriorityCount > highPriorityCount && highPriorityCount > 0) {
                updateAIMessage(getAIMessage('lowPriorityFocus'));
            }
        }
        
        // ============================================
        // BEHAVIORAL PATTERN DETECTION (V20.6)
        // ============================================
        
        // Check for repeated low-energy selections with high-priority work pending
        function checkPriorityMismatch() {
            // Count high-priority incomplete tasks
            let highPriorityCount = 0;
            ['admin', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    if (!task.completed && task.priority === 'high') {
                        highPriorityCount++;
                    }
                });
            });
            
            // If high-priority work exists and user keeps choosing low energy
            if (highPriorityCount > 0 && state.lowEnergyChoiceCount >= 3) {
                const message = getAICoachMessage('priorityMismatch', {
                    lowEnergyCount: state.lowEnergyChoiceCount
                });
                updateAIMessage(message);
                
                // V20.6: Softer approach - prompt without blocking
                showToast('Consider tackling high-priority work with more energy.', 'warning', 5000);
                
                state.lowEnergyChoiceCount = 0;
                saveState();
                return true;
            }
            return false;
        }
        
        // Check if break is earned (V20.6)
        function checkBreakEligibility() {
            const MIN_FOCUS_FOR_BREAK = 15; // Minutes
            
            // If trying to take a break without sufficient focus
            if (state.totalFocusTime < MIN_FOCUS_FOR_BREAK) {
                const message = getAICoachMessage('breakDenied', {
                    focusTime: state.totalFocusTime,
                    breakAttempts: state.consecutiveBreaks + 1
                });
                
                updateAIMessage(message);
                showToast('Consider doing some focus work before taking a break.', 'warning', 4000);
                return false; // Block break if zero focus
            }
            
            // Check if too many consecutive breaks - prompt but allow
            if (state.consecutiveBreaks >= 2) {
                const focusBreakRatio = state.totalFocusTime / Math.max(1, state.totalBreakTime);
                
                if (focusBreakRatio < 2) { // Less than 2:1 focus:break ratio
                    const message = getAICoachMessage('excessiveBreaks', {
                        consecutiveBreaks: state.consecutiveBreaks,
                        focusBreakRatio: focusBreakRatio.toFixed(1)
                    });
                    
                    updateAIMessage(message);
                    showToast('Break frequency is high. Consider balancing with focus time.', 'warning', 5000);
                    // Allow break but with warning
                }
            }
            
            return true;
        }
        
        // Detect extended idle without decision (V20.6)
        function checkIdleState() {
            if (!state.idleStartTime) {
                state.idleStartTime = Date.now();
                return;
            }
            
            const idleMinutes = Math.floor((Date.now() - state.idleStartTime) / 60000);
            
            if (idleMinutes >= 5) { // 5 minutes idle - extended period
                const message = getAICoachMessage('idleInterruption', {
                    idleMinutes: idleMinutes
                });
                
                updateAIMessage(message);
                showToast('You\'ve been idle for a while. Choose your next move.', 'info', 5000);
                
                state.idleStartTime = Date.now(); // Reset to avoid spam
            }
        }
        
        // Track sprint aborts for avoidance pattern (V20.6)
        function detectAvoidancePattern() {
            if (state.sprintAborts >= 3) {
                const message = getAICoachMessage('avoidancePattern', {
                    abortCount: state.sprintAborts
                });
                
                updateAIMessage(message);
                state.sprintAborts = 0;
                saveState();
            }
        }
        
        // Detect avoidance patterns and provide coaching (V20.6)
        let avoidanceMessageCount = 0;
        function detectAvoidanceCoaching() {
            avoidanceMessageCount++;
            
            if (avoidanceMessageCount >= 3) {
                const message = getAICoachMessage('cleanExit', {
                    refusalCount: avoidanceMessageCount
                });
                
                updateAIMessage(message);
                showToast('Consider whether this is the right time to work.', 'info', 5000);
                avoidanceMessageCount = 0; // Reset counter
            }
        }
        
        // Intervention modal system (V20.6)
        function showInterventionModal(message, actions, dismissable = false) {
            // Create modal if doesn't exist
            let modal = document.getElementById('interventionModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'interventionModal';
                modal.className = 'intervention-modal';
                modal.innerHTML = `
                    <div class="intervention-content">
                        <div class="intervention-message"></div>
                        <div class="intervention-actions"></div>
                    </div>
                `;
                document.body.appendChild(modal);
            }
            
            // Set message
            modal.querySelector('.intervention-message').textContent = message;
            
            // Set actions
            const actionsContainer = modal.querySelector('.intervention-actions');
            actionsContainer.innerHTML = '';
            
            actions.forEach(action => {
                const btn = document.createElement('button');
                btn.textContent = action.text;
                btn.className = 'btn intervention-btn';
                btn.onclick = action.action;
                actionsContainer.appendChild(btn);
            });
            
            // Show modal
            modal.style.display = 'flex';
            
            // Handle dismissal
            if (dismissable) {
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        detectRefusalPattern();
                        hideInterventionModal();
                    }
                };
            }
        }
        
        function hideInterventionModal() {
            const modal = document.getElementById('interventionModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        // Monitor inactivity
        let inactivityTimer = null;
        function startInactivityMonitor() {
            clearTimeout(inactivityTimer);
            
            // If session active and no sprint running, check for prolonged inactivity
            if (state.dayActive && !state.timer.active) {
                inactivityTimer = setTimeout(() => {
                    const totalRequired = calculateTotalRequiredSprints();
                    const message = getAICoachMessage('inactivity', {
                        minutesIdle: 2,
                        sprintsDone: state.sprintCount,
                        required: totalRequired
                    });
                    updateAIMessage(message);
                    
                    // V20.6: Check for idle intervention
                    checkIdleState();
                    
                    // Remind again every 2 minutes
                    startInactivityMonitor();
                }, 120000); // 2 minutes
            }
        }
        
        function resetInactivityMonitor() {
            clearTimeout(inactivityTimer);
            if (state.dayActive && !state.timer.active) {
                startInactivityMonitor();
            }
        }
        
        // ============================================
        // AI COACH - CONTINUOUS MONITORING
        // ============================================
        let aiMonitoringInterval = null;
        
        function startAIMonitoring() {
            // Clear any existing monitor
            if (aiMonitoringInterval) {
                clearInterval(aiMonitoringInterval);
            }
            
            // Check every 30 seconds
            aiMonitoringInterval = setInterval(() => {
                if (!state.dayActive) return;
                
                const totalRequired = calculateTotalRequiredSprints();
                const gap = totalRequired - state.sprintCount;
                
                // Don't interrupt if timer is active (let sprint complete handle it)
                if (state.timer.active) return;
                
                // Check various conditions
                checkPerformanceStatus(gap, totalRequired);
            }, 30000); // Every 30 seconds
            
            console.log('ü§ñ AI Monitoring started (checks every 30s)');
        }
        
        function checkPerformanceStatus(gap, totalRequired) {
            const tasksLeft = ['admin', 'deepwork', 'strategic'].reduce((sum, bucket) => 
                sum + state.tasks[bucket].filter(t => !t.completed).length, 0);
            
            // Critical: Way behind schedule
            if (gap > 5 && tasksLeft > 3) {
                updateAIMessage(`‚ö†Ô∏è CRITICAL: ${gap} sprints behind with ${tasksLeft} tasks remaining. Performance deficit severe. Start sprint immediately.`);
                return;
            }
            
            // Behind schedule  
            if (gap > 2 && tasksLeft > 0) {
                const messages = [
                    `${gap} sprint${gap > 1 ? 's' : ''} behind schedule. ${tasksLeft} task${tasksLeft > 1 ? 's' : ''} pending. Execute now.`,
                    `Performance gap: ${gap} sprints. Current pace insufficient to meet requirements. Accelerate.`,
                    `Behind by ${gap}. Each delay compounds. Start next sprint.`
                ];
                updateAIMessage(messages[Math.floor(Math.random() * messages.length)]);
                return;
            }
            
            // Check priority misalignment
            checkPriorityAlignment();
        }
        
        // Enhanced priority check
        function checkPriorityAlignment() {
            let lowPriorityCount = 0;
            let highPriorityCount = 0;
            let lowPriorityTasks = [];
            let highPriorityTasks = [];
            
            ['admin', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    if (!task.completed) {
                        if (task.priority === 'low') {
                            lowPriorityCount++;
                            lowPriorityTasks.push(task.title);
                        }
                        if (task.priority === 'high') {
                            highPriorityCount++;
                            highPriorityTasks.push(task.title);
                        }
                    }
                });
            });
            
            // Alert if focusing on low priority when high priority exists
            if (lowPriorityCount > highPriorityCount && highPriorityCount > 0) {
                updateAIMessage(`‚ö†Ô∏è Priority misalignment: ${lowPriorityCount} low-priority vs ${highPriorityCount} high-priority items. Focus on high-value work: ${highPriorityTasks[0]}.`);
            }
        }

        function showMicroConfirm(message) {
            const el = document.getElementById('microConfirm');
            if (el) {
                el.textContent = message;
                el.classList.remove('hidden');
                setTimeout(() => el.classList.add('hidden'), 2000);
            }
        }

        function parkDistraction() {
            const input = document.getElementById('distractionInput');
            const text = input.value.trim();
            if (!text) return;
            
            // STORE THE DISTRACTION with timestamp
            const distraction = {
                id: 'dist_' + Date.now(),
                text: text,
                timestamp: Date.now(),
                handleLater: document.getElementById('handleLaterCheck').checked
            };
            
            state.distractions.push(distraction);
            state.distractionCount++;
            
            // Clear input
            input.value = '';
            document.getElementById('handleLaterCheck').checked = false;
            
            // AI COACH: Contextual distraction message
            const message = getAICoachMessage('distractionParked', {
                distractionCount: state.distractionCount
            });
            updateAIMessage(message);
            
            saveState();
            renderAll();
            showMicroConfirm('Distraction parked');
            
            // Log to console for debugging
            console.log('üö´ Distraction parked:', distraction);
        }

        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', newTheme);
            
            const logo = document.getElementById('appLogo');
            if (newTheme === 'dark') {
                logo.src = 'FocusHub_horiinv.svg';
                document.getElementById('themeToggle').textContent = 'DARK';
            } else {
                logo.src = 'FocusHub_horinorm.svg';
                document.getElementById('themeToggle').textContent = 'LIGHT';
            }
            
            localStorage.setItem('focushub_theme', newTheme);
        }

        function syncThemeUI() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const logo = document.getElementById('appLogo');
            const themeToggle = document.getElementById('themeToggle');
            
            if (!logo || !themeToggle) return; // Safety check
            
            if (currentTheme === 'dark') {
                logo.src = 'FocusHub_horiinv.svg';
                themeToggle.textContent = 'DARK';
            } else {
                logo.src = 'FocusHub_horinorm.svg';
                themeToggle.textContent = 'LIGHT';
            }
        }

        // ============================================
        // START DAY FLOW
        // ============================================
        
        // Load reflections from external files (350+ professional reflections)
        // reflections-expanded.js is loaded in <head>
        // Each tradition-specific file (reflections-buddhist.js, etc.) can be loaded as needed
        
        function showStartDayModal() {
            // Hide main app
            document.querySelector('.app-container').style.display = 'none';
            
            // Show modal
            const modal = document.getElementById('startDayModal');
            modal.style.display = 'flex';
            
            // Get user's reflection tradition preference (default to secular)
            const tradition = localStorage.getItem('focushub_reflection_tradition') || 'secular';
            
            // Get reflections based on tradition
            // For now, use EXPANDED_REFLECTIONS (universal/secular)
            // TODO: Load tradition-specific files dynamically if needed
            const reflections = typeof EXPANDED_REFLECTIONS !== 'undefined' ? EXPANDED_REFLECTIONS : [];
            
            // Fallback if no reflections loaded
            if (reflections.length === 0) {
                document.getElementById('dailyReflection').textContent = "Focus is the art of knowing what to ignore.";
                document.getElementById('reflectionSource').textContent = "‚Äî Practical Wisdom";
                return;
            }
            
            // Pick random reflection
            const reflection = reflections[Math.floor(Math.random() * reflections.length)];
            
            // Display reflection (format from expanded library)
            document.getElementById('dailyReflection').textContent = reflection.text;
            document.getElementById('reflectionSource').textContent = reflection.attribution || reflection.headline;
            
            // Set up start button
            document.getElementById('startDayBtn').addEventListener('click', startNewDay);
        }
        
        function startNewDay() {
            // Get selected energy level
            const energySelect = document.getElementById('startDayEnergy');
            const selectedEnergy = energySelect.value;
            
            // Set energy level in state
            state.energyLevel = selectedEnergy;
            localStorage.setItem('focushub_energy', selectedEnergy);
            
            // Update timer duration based on energy
            const energyTimers = { low: 15, medium: 20, high: 30 };
            state.timer.duration = energyTimers[selectedEnergy];
            state.timer.remaining = state.timer.duration * 60;
            
            // Mark day as active
            state.dayActive = true;
            state.lastDayStarted = Date.now();
            state.lastActivityTime = Date.now();
            
            // FIXED: Reset daily sprint target so it recalculates with today's tasks
            state.dailySprintTarget = 0;
            
            // Save state
            saveState();
            
            // Hide modal and show app
            document.getElementById('startDayModal').style.display = 'none';
            document.querySelector('.app-container').style.display = 'grid';
            
            // Initialize app
            setupEventListeners();
            setupDropZones();
            renderAll();
            
            // Record activity on interactions
            document.addEventListener('click', recordActivity);
            document.addEventListener('keypress', recordActivity);
            
            console.log('‚úÖ Day started successfully');
        }

        // ============================================
        // INITIALIZE
        // ============================================
        // ============================================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
    
    <!-- PREMIUM: Remove preload class to enable transitions -->
    <script>
        window.addEventListener('load', () => {
            document.body.classList.remove('preload');
            
            // Initialize keyboard shortcuts (premium feature)
            if (typeof initializeKeyboardShortcuts === 'function') {
                initializeKeyboardShortcuts();
            }
        });
    </script>
    
    <!-- Start Day Modal -->
    <div id="startDayModal" class="start-day-modal" style="display: none;">
        <div class="start-day-content">
            <div class="start-day-header">
                <h2>START YOUR DAY</h2>
                <p class="start-day-subtitle">System Initialization Required</p>
            </div>
            
            <!-- Daily Reflection -->
            <div class="reflection-section">
                <h3 class="reflection-label">DAILY REFLECTION</h3>
                <div class="reflection-text" id="dailyReflection">
                    Loading wisdom...
                </div>
                <div class="reflection-source" id="reflectionSource"></div>
            </div>
            
            <!-- Energy Selection -->
            <div class="energy-section">
                <label class="energy-label">ENERGY LEVEL ASSESSMENT</label>
                <select id="startDayEnergy" class="start-day-energy-select">
                    <option value="low">LOW - Kinda "Meh" (15 min sprints)</option>
                    <option value="medium" selected>MED - Solid (20 min sprints)</option>
                    <option value="high">HIGH - Locked In (30 min sprints)</option>
                </select>
            </div>
            
            <!-- Start Button -->
            <button id="startDayBtn" class="btn-start-day">START SESSION</button>
        </div>
    </div>

    <!-- Footer -->
    <footer class="app-footer">
        <div class="footer-links">
            <a href="settings.html" class="footer-link">‚öôÔ∏è Settings</a>
            <a href="https://docs.focushub.app" target="_blank" class="footer-link">üìö How-To Guide</a>
            <a href="/cdn-cgi/l/email-protection#a8dbddd8d8c7dadce8cec7cbdddbc0ddca86c9d8d8" class="footer-link">üí¨ Support</a>
            <a href="/cdn-cgi/l/email-protection#244c4148484b64424b4751574c51460a455454" class="footer-link">‚úâÔ∏è Contact</a>
        </div>
        <div class="footer-copyright">
            ¬© 2026 FocusHub. All rights reserved.
        </div>
    </footer>
    <script>
        // PWA Service Worker Registration (V20.4) - DISABLED due to cache errors
        // V20.6: Aggressively unregister any existing service worker and clear cache
        if ("serviceWorker" in navigator) {
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for(let registration of registrations) {
                    registration.unregister();
                    console.log('üßπ Service worker unregistered');
                }
            });
            
            // Also clear all caches
            if ('caches' in window) {
                caches.keys().then(function(names) {
                    for (let name of names) {
                        caches.delete(name);
                        console.log('üßπ Cache cleared:', name);
                    }
                });
            }
        }
    </script>
</body>
</html>

    <!-- Toast Container -->
    <div id="toastContainer" style="position: fixed; bottom: 2rem; right: 2rem; z-index: 10000; display: flex; flex-direction: column; gap: 0.5rem;"></div>

    <script>
        // ============================================
        // TOAST NOTIFICATION SYSTEM (V20.4)
        // ============================================
        function showToast(message, type = 'info', duration = 3000) {
            const container = document.getElementById('toastContainer');
            if (!container) return;
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type} fade-in`;
            
            // Icon based on type
            const icons = {
                success: '‚úì',
                error: '‚úó',
                info: '‚Ñπ',
                warning: '‚ö†'
            };
            
            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 0.75rem;">
                    <span style="font-size: 1.25rem;">${icons[type] || icons.info}</span>
                    <span style="font-family: 'JetBrains Mono', monospace; font-size: 0.875rem;">${message}</span>
                </div>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(100%)';
                setTimeout(() => toast.remove(), 300);
            }, duration);
            
            console.log(`üîî Toast: [${type.toUpperCase()}] ${message}`);
        }
        
        // Replace alerts with toasts globally
        window.showNotification = showToast;
    </script>

    <!-- ============================================
         ONBOARDING SYSTEM (V20.5)
         ============================================ -->
    <script>
        // Check if user has seen onboarding
        function checkOnboarding() {
            const hasSeenOnboarding = localStorage.getItem('focushub_onboarding_complete');
            if (!hasSeenOnboarding && state.dayActive) {
                document.getElementById('onboardingModal').style.display = 'flex';
            }
        }

        function showOnboardingStep(stepNumber) {
            // Hide all steps
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`onboard-step-${i}`).style.display = 'none';
            }
            // Show requested step
            document.getElementById(`onboard-step-${stepNumber}`).style.display = 'block';
        }

        function finishOnboarding() {
            localStorage.setItem('focushub_onboarding_complete', 'true');
            document.getElementById('onboardingModal').style.display = 'none';
            showToast('Welcome to FocusHub! Let\'s get to work.', 'success');
        }
    </script>
</body>
</html>
