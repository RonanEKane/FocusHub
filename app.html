<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>FocusHub - Workspace</title>
    <link rel="stylesheet" href="style.css">
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
    <script src="reflections-expanded.js"></script>
    <script src="reflections-catholic.js"></script>
    <script src="reflections-christian.js"></script>
    <script src="reflections-jewish.js"></script>
    <script src="reflections-islamic.js"></script>
    <script src="reflections-hindu.js"></script>
    <script src="reflections-buddhist.js"></script>
</head>
<body>
    <!-- Start Day Screen -->
    <div id="startDayScreen" class="start-day-screen">
        <div class="start-day-container">
            <img id="startDayLogo" src="FocusHub_vertnorm.svg" alt="FocusHub" style="height: 80px; width: auto; margin: 0 auto 1.5rem; display: block;">
            <h1 class="start-title">Prepare your session</h1>
            <p class="start-subtitle">Define today's work requirements. The system enforces them.</p>
            <p style="text-align: center; font-size: 0.875rem; color: var(--text-secondary); margin: 0 auto 2rem; max-width: 500px; line-height: 1.5;">
                This step defines the structure for today's session. Once started, the execution environment is locked.
            </p>

            <div class="start-form">
                <div class="form-group">
                    <label class="form-label" style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">‚ö° Energy Check-In</label>
                    <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem;">Your current energy level adjusts sprint expectations.</p>
                    <div class="energy-options">
                        <button class="energy-btn" data-energy="high" style="cursor: pointer; transition: all 0.2s;">
                            <div class="energy-emoji">üîã</div>
                            <div style="font-weight: 600;">HIGH ENERGY</div>
                            <div class="energy-desc" data-energy-desc="high">30min sprints</div>
                        </button>
                        <button class="energy-btn active" data-energy="medium" style="cursor: pointer; transition: all 0.2s;">
                            <div class="energy-emoji">‚ö°</div>
                            <div style="font-weight: 600;">MEDIUM ENERGY</div>
                            <div class="energy-desc" data-energy-desc="medium">20min sprints</div>
                        </button>
                        <button class="energy-btn" data-energy="low" style="cursor: pointer; transition: all 0.2s;">
                            <div class="energy-emoji">ü™´</div>
                            <div style="font-weight: 600;">LOW ENERGY</div>
                            <div class="energy-desc" data-energy-desc="low">15min sprints</div>
                        </button>
                    </div>
                </div>

                <!-- PREMIUM: Reflection Tradition Selector -->
                <div class="form-group" id="reflectionTraditionGroup" style="display: none;">
                    <label class="form-label" style="font-size: 1.25rem; font-weight: 600; margin-bottom: 0.5rem;">üôè Daily Reflection Type</label>
                    <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem;">Choose reflections aligned with your spiritual tradition.</p>
                    <select id="reflectionTraditionSelect" style="width: 100%; padding: 0.75rem; font-size: 1rem; border: 2px solid var(--border-medium); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); cursor: pointer;">
                        <option value="universal">Non-Denominational (Universal Wisdom)</option>
                        <option value="catholic">Catholic (Saints, Scripture, Church Teaching)</option>
                        <option value="christian">Christian (Protestant Traditions)</option>
                        <option value="jewish">Jewish (Torah, Talmud, Rabbinical Wisdom)</option>
                        <option value="islamic">Islamic (Quran, Hadith, Scholars)</option>
                        <option value="hindu">Hindu (Bhagavad Gita, Upanishads)</option>
                        <option value="buddhist">Buddhist (Dhammapada, Zen, Teachers)</option>
                    </select>
                    <div class="form-hint">Premium feature - Beta users get this forever!</div>
                </div>

                <div class="form-group">
                    <label class="form-label">Sprint Configuration</label>
                    <div class="baseline-input-row">
                        <button class="baseline-btn" id="decreaseBaseline">‚àí</button>
                        <div class="baseline-value"><span id="baselineValue">5</span> sprints</div>
                        <button class="baseline-btn" id="increaseBaseline">+</button>
                    </div>
                    <div class="form-hint">Sprint count defines the amount of focused work required today.</div>
                </div>
                
                <div style="text-align: center; margin-bottom: 1.5rem; padding: 0.75rem; background: rgba(245, 91, 7, 0.1); border-left: 3px solid var(--industrial-orange); font-size: 0.875rem; color: var(--text-secondary);">
                    Tasks added here become your active execution list.
                </div>

                <button class="btn btn-primary btn-start" id="startDayBtn">Start session</button>
                
                <p style="text-align: center; font-size: 0.75rem; color: var(--text-secondary); margin-top: 1rem; opacity: 0.7;">
                    Session settings can be adjusted later if needed.
                </p>
            </div>
        </div>
    </div>

    <script>
        // Update start screen logo based on theme
        function updateStartScreenLogo() {
            const theme = localStorage.getItem('focushub_theme') || 'light';
            const logo = document.getElementById('startDayLogo');
            if (logo) {
                logo.src = theme === 'dark' ? 'FocusHub_vertdark.svg' : 'FocusHub_vertnorm.svg';
            }
        }
        
        // Run on load
        updateStartScreenLogo();
        
        // Re-run if theme changes
        window.addEventListener('storage', updateStartScreenLogo);
    </script>

    <!-- Main App (hidden initially) -->
    <div id="mainApp" class="hidden">
        <!-- Header -->
        <header class="app-header">
            <div class="app-header-content">
                <div class="logo-section">
                    <div style="position: relative; display: inline-block;">
                        <img id="appLogo" src="FocusHub_horinorm.svg" alt="FocusHub" class="logo-img">
                        <span style="position: absolute; top: -6px; right: -38px; background: #f45b07; color: white; font-size: 10px; font-weight: 700; padding: 2px 6px; border-radius: 3px; letter-spacing: 0.5px;">BETA</span>
                    </div>
                    <p class="tagline">Built for Brains That Wander, but Still Want to Win</p>
                </div>
                
                <div class="header-middle" id="headerTimer">
                    <!-- Timer shows here when scrolled -->
                </div>
                
                <div class="header-controls">
                    <a href="overview.html" class="btn-home">üìä Dashboard</a>
                    <button id="themeToggle" class="btn-home">‚òÄÔ∏è Light</button>
                    <button id="logoutBtn" class="btn-home" style="color: var(--text-secondary);">Logout</button>
                    <button id="endDayBtn" class="btn-end-day" data-label="endDay">END DAY</button>
                </div>
            </div>
        </header>

        <div class="app-container">
            <!-- Main Content (Left Column) -->
            <div class="main-content">
                <!-- Sprint Timer -->
                <div class="card sprint-timer" style="margin-bottom: 2rem; border: 3px solid var(--industrial-orange); box-shadow: 0 4px 16px rgba(245, 91, 7, 0.3); background: rgba(245, 91, 7, 0.03);">
                    <div class="card-header">
                        <h3 class="card-title" id="timerTitle">üéØ SPRINT TIMER</h3>
                        <div style="display: flex; gap: 1rem; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <label style="font-size: 0.875rem; color: var(--text-secondary); font-weight: 500;">Energy:</label>
                                <select id="energySelect" style="padding: 0.375rem 0.5rem; border: 1px solid var(--border-light); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 0.875rem; cursor: pointer;">
                                    <option value="high">üîã Full Power</option>
                                    <option value="medium" selected>‚ö° Kinda 'Meh'</option>
                                    <option value="low">ü™´ On Fumes</option>
                                </select>
                            </div>
                            <div class="timer-meeting">
                                <button id="meetingBtn" class="btn-meeting" data-label="meeting">üìÖ Meeting</button>
                                <span id="meetingTime" class="meeting-time hidden">0m</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card-content">
                        <!-- System State Indicator -->
                        <div id="systemState" style="text-align: center; font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 1rem; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: 500; letter-spacing: 0.025em;">
                            System idle. Start a sprint to begin.
                        </div>
                        
                        <!-- Current Task Display -->
                        <div id="currentTaskDisplay" class="hidden" style="text-align: center; padding: 0.75rem; background: rgba(74, 144, 226, 0.1); border: 1px solid var(--accent-blue); border-radius: 6px; margin-bottom: 1rem; font-size: 0.875rem;"></div>
                        
                        <div id="timerSetup" class="timer-setup">
                            <div class="duration-buttons" style="display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center; margin-top: 1rem;">
                                <button class="duration-btn" data-duration="15" data-type="focus" style="flex: 1; min-width: 120px; font-size: 1.1rem; padding: 1rem;">15 min</button>
                                <button class="duration-btn recommended" data-duration="20" data-type="focus" style="flex: 1; min-width: 120px; font-size: 1.1rem; padding: 1rem;">20 min</button>
                                <button class="duration-btn" data-duration="30" data-type="focus" style="flex: 1; min-width: 120px; font-size: 1.1rem; padding: 1rem;">30 min</button>
                                <button class="duration-btn" id="breakBtn" data-type="break" data-duration="5" style="flex: 1; min-width: 120px; font-size: 1.1rem; padding: 1rem; background: var(--success); color: white;">Break (5 min)</button>
                            </div>
                            
                            <!-- First-run helper text -->
                            <div id="firstRunTimerHelper" class="first-run-helper" style="display: none; text-align: center; margin-top: 1rem; padding: 0.75rem; background: rgba(245, 91, 7, 0.1); border-left: 3px solid var(--industrial-orange); font-size: 14px; color: var(--text-secondary);">
                                Start a session to begin working.
                            </div>
                        </div>

                        <div id="timerActive" class="timer-active hidden" style="padding: 1.5rem; background: rgba(255, 255, 255, 0.02); border-radius: 8px;">
                            <div class="timer-display">
                                <div class="timer-time" id="timerTime" style="font-size: 5rem; font-weight: 700;">20:00</div>
                                <div class="timer-progress">
                                    <div class="progress-bar" id="progressBar"></div>
                                </div>
                            </div>
                            
                            <div class="timer-controls">
                                <button id="pauseBtn" class="btn" style="background: var(--warning); color: #1a1a1a; font-weight: 600; flex: 1;">‚è∏ PAUSE</button>
                                <button id="resetBtn" class="btn btn-danger" style="flex: 1;">üîÑ RESET</button>
                                <button id="completeBreakBtn" class="btn btn-success hidden" style="flex: 1;">‚úì End Break</button>
                            </div>
                            
                            <!-- Pause Confirmation (hidden by default) -->
                            <div id="pauseConfirm" class="pause-confirm hidden" style="margin-top: 1rem; padding: 1rem; background: rgba(251, 191, 36, 0.1); border: 2px solid var(--warning); border-radius: 6px;">
                                <p style="font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.75rem; font-weight: 500;">
                                    Pausing breaks momentum. Are you sure you can't push through?
                                </p>
                                <div style="display: flex; gap: 0.5rem;">
                                    <button id="confirmPauseBtn" class="btn btn-secondary" style="flex: 1; font-size: 0.875rem;">Yes, Pause</button>
                                    <button id="cancelPauseBtn" class="btn btn-primary" style="flex: 2; font-size: 0.875rem;">No, Keep Going</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Task Manager -->
                <div class="card task-manager" style="border: 1px solid var(--border-light);">
                    <div class="task-header">
                        <h2>‚ö° TASK COMMAND CENTER</h2>
                        <div class="sprint-target">
                            Target: <strong><span id="plannedSprints">5</span></strong> sprints
                        </div>
                    </div>
                    
                    <!-- Active List Message -->
                    <div style="text-align: center; padding: 0.75rem; margin-bottom: 1rem; background: rgba(245, 91, 7, 0.1); border-left: 3px solid var(--industrial-orange); font-size: 0.875rem; color: var(--text-secondary); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-weight: 500;">
                        This list exists to be cleared.
                    </div>

                    <!-- Brain Dump -->
                    <div class="brain-dump">
                        <label data-label="brainDump">üß† BRAIN DUMP</label>
                        <p class="brain-dump-hint">Paste your task list below (one task per line)</p>
                        <textarea id="taskInput" class="task-textarea" data-label="taskEntry" placeholder="What needs doing?" rows="4"></textarea>
                        
                        <!-- First-run helper text -->
                        <div id="firstRunTaskHelper" class="first-run-helper" style="display: none; margin-top: 0.5rem; padding: 0.5rem; font-size: 13px; color: var(--text-secondary); font-style: italic;">
                            Tasks define what sessions are for.
                        </div>
                        
                        <!-- Subject Selection (Student Mode Only) -->
                        <div id="subjectSection" class="subject-section hidden" style="margin-top: 0.75rem;">
                            <label style="font-size: 0.875rem; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 0.5rem;">üìö Subject (Optional)</label>
                            <select id="subjectSelect" class="subject-select" style="width: 100%; padding: 0.625rem; border: 1px solid var(--border-light); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 0.875rem;">
                                <option value="">Select subject...</option>
                                <!-- Options populated by config.js -->
                            </select>
                            <input type="text" id="customSubjectInput" class="custom-subject-input hidden" placeholder="Enter custom subject..." style="width: 100%; margin-top: 0.5rem; padding: 0.625rem; border: 1px solid var(--border-light); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 0.875rem;">
                        </div>
                        
                        <button id="addTaskBtn" class="btn btn-primary" style="width: 100%; margin-top: 0.5rem;">Parse & Add to <span data-label="holding">Holding</span></button>
                        
                        <!-- Holding Area -->
                        <div id="holdingArea" class="holding-area" style="margin-top: 1rem; opacity: 0.7; padding: 1rem; background: rgba(255, 255, 255, 0.02); border: 1px dashed var(--border-light); border-radius: 4px;">
                            <div class="holding-header">
                                <span style="font-size: 0.875rem; color: var(--text-secondary);">üìã <span data-label="holding">PARKING LOT</span></span>
                                <span class="task-count" id="holdingCount" style="opacity: 0.7;">0</span>
                            </div>
                            <div id="holdingList" class="task-list" data-bucket="holding" style="min-height: 60px; padding: 0.5rem; border-radius: 4px; transition: background 0.2s;"></div>
                        </div>
                    </div>

                    <!-- Task Buckets -->
                    <div class="task-buckets" style="margin-top: 1.5rem; padding: 1rem; background: rgba(245, 91, 7, 0.03); border: 2px solid rgba(245, 91, 7, 0.3); border-radius: 8px;">
                        <div class="task-bucket urgent" data-bucket="urgent" style="border-left: 3px solid var(--accent-red);">
                            <div class="bucket-header">
                                <span class="bucket-icon">üî•</span>
                                <h3 data-label="urgent">ADMIN</h3>
                                <span class="task-count" id="urgentCount">0</span>
                            </div>
                            <div id="urgentList" class="task-list" data-bucket="urgent" style="min-height: 60px; padding: 0.5rem; border-radius: 4px; transition: background 0.2s;"></div>
                        </div>

                        <div class="task-bucket deepwork" data-bucket="deepwork" style="border-left: 3px solid var(--accent-blue);">
                            <div class="bucket-header">
                                <span class="bucket-icon">üéØ</span>
                                <h3 data-label="deepwork">DEEP WORK</h3>
                                <span class="task-count" id="deepworkCount">0</span>
                            </div>
                            <div id="deepworkList" class="task-list" data-bucket="deepwork" style="min-height: 60px; padding: 0.5rem; border-radius: 4px; transition: background 0.2s;"></div>
                        </div>

                        <div class="task-bucket strategic" data-bucket="strategic" style="border-left: 3px solid var(--industrial-orange);">
                            <div class="bucket-header">
                                <span class="bucket-icon">‚ôüÔ∏è</span>
                                <h3 data-label="strategic">STRATEGIC</h3>
                                <span class="task-count" id="strategicCount">0</span>
                            </div>
                            <div id="strategicList" class="task-list" data-bucket="strategic" style="min-height: 60px; padding: 0.5rem; border-radius: 4px; transition: background 0.2s;"></div>
                        </div>
                    </div>

                    <!-- Today's Wins -->
                    <div id="winsSection" class="wins-section hidden">
                        <div class="wins-header">
                            <h3>‚úÖ TODAY'S WINS</h3>
                        </div>
                        <div id="winsList" class="wins-list"></div>
                    </div>

                    <div class="task-weights-legend">
                        <small><strong>Priority (within bucket):</strong> üî¥ High ¬∑ üü° Medium ¬∑ üü¢ Low &nbsp;|&nbsp; <strong>Sprint Values:</strong> Admin (1) ¬∑ Deep Work (2) ¬∑ Strategic (3)</small>
                    </div>
                </div>
            </div>

            <!-- Sidebar (Right Column - NOT STICKY) -->
            <div class="sidebar-column">
                <!-- NEW: Tough Love Toggle -->
                <!-- System Intelligence with Focus Control -->
                <div class="card ai-agent" style="border: 2px solid var(--accent-blue); box-shadow: 0 2px 12px rgba(37, 99, 235, 0.2); background: rgba(37, 99, 235, 0.02);">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem;">
                        <div>
                            <h3 class="card-title" style="margin-bottom: 0.25rem; font-weight: 700;">System Intelligence</h3>
                            <div style="font-style: italic; font-size: 0.875rem; color: var(--text-secondary);">Focus Control</div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 0.25rem;">
                            <label for="toughLoveSelect" style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px;">Tone</label>
                            <select id="toughLoveSelect" style="padding: 0.375rem 0.5rem; border: 1px solid var(--border-light); border-radius: 4px; background: var(--bg-secondary); color: var(--text-primary); font-size: 0.875rem; cursor: pointer;">
                                <option value="supportive">Supportive</option>
                                <option value="balanced" selected>Balanced</option>
                                <option value="tough">Tough</option>
                            </select>
                        </div>
                    </div>
                    <div class="agent-message" style="padding: 1.5rem; background: var(--bg-secondary); border-left: 4px solid var(--accent-blue); border-radius: 4px; min-height: 80px;">
                        <div class="agent-text" id="agentText" style="font-size: 1.1rem; line-height: 1.6; font-weight: 500;">Start your first sprint to get feedback.</div>
                    </div>
                    
                    <!-- Progress tracking inside AI Agent card -->
                    <div class="progress-grid" style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light);">
                        <div class="progress-item">
                            <div class="progress-label">Sprints</div>
                            <div class="progress-value"><span id="sprintProgress">0</span> / <span id="sprintTarget">5</span></div>
                        </div>
                        <div class="progress-item">
                            <div class="progress-label">Wins</div>
                            <div class="progress-value" id="taskProgress">0</div>
                        </div>
                        <div class="progress-item">
                            <div class="progress-label">Breaks</div>
                            <div class="progress-value" id="breaksProgress">0</div>
                        </div>
                        <div class="progress-item">
                            <div class="progress-label">Distractions</div>
                            <div class="progress-value" id="distractionProgress">0</div>
                        </div>
                    </div>
                </div>

                <!-- Distraction Logger with Intention Tracking -->
                <div class="card distraction-logger collapsed" style="border: 1px solid var(--border-light);">
                    <div class="card-header" onclick="toggleCard('distraction')" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <h3 class="card-title">üö´ DISTRACTION PARKING</h3>
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span class="distraction-count" id="distractionCount">0</span>
                            <span class="toggle-indicator" id="distractionToggle" style="font-size: 0.75rem; color: var(--text-secondary);">‚ñ∂</span>
                        </div>
                    </div>
                    
                    <div class="card-content" id="distractionContent" style="display: none;">
                        <!-- Add Intention Toggle -->
                        <div class="distraction-input-group">
                            <input type="text" id="distractionInput" class="distraction-input" placeholder="Park that distraction here...">
                            <label class="intention-checkbox">
                                <input type="checkbox" id="intentionCheck">
                                <span>I'll handle this</span>
                            </label>
                            <button id="parkDistractionBtn" class="btn btn-primary">Park It</button>
                        </div>

                        <div id="distractionList" class="distraction-list"></div>
                    </div>
                </div>

                <!-- Grade Preview -->
                <div class="card grade-preview collapsed" style="border: 1px solid var(--border-light);">
                    <h3 class="card-title" onclick="toggleCard('grade')" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <span>üìà CURRENT GRADE</span>
                        <span class="toggle-indicator" id="gradeToggle" style="font-size: 0.75rem; color: var(--text-secondary);">‚ñ∂</span>
                    </h3>
                    <div class="grade-display" id="gradeContent" style="display: none;">
                        <div class="grade-large" id="currentGrade">-</div>
                        <div class="grade-context">Based on current progress</div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="app-footer">
            <a href="overview.html">üìä Dashboard</a>
            <span class="footer-separator">|</span>
            <a href="how-to.html">üìñ How-to</a>
            <span class="footer-separator">|</span>
            <a href="guide.html">üí¨ Support</a>
            <span class="footer-separator">|</span>
            <a href="#" onclick="openFeedbackModal(); return false;" style="color: var(--industrial-orange);">üéØ Beta Feedback</a>
        </footer>
    </div>

    <!-- Feedback Modal -->
    <div id="feedbackModal" class="modal-overlay hidden">
        <div class="modal feedback-modal">
            <div class="modal-header">
                <h2>üéØ Beta Feedback</h2>
                <button class="modal-close" onclick="closeFeedbackModal()">√ó</button>
            </div>
            
            <div class="modal-body">
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
                    Your feedback helps make FocusHub better for everyone with ADHD.
                </p>
                
                <!-- Feedback Type -->
                <div style="margin-bottom: 1.5rem;">
                    <label class="form-label">What's this about?</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem;">
                        <button class="feedback-type-btn active" data-type="bug" style="padding: 0.75rem; border: 2px solid var(--border-light); border-radius: 6px; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s; font-size: 0.875rem;">
                            üêõ Bug Report
                        </button>
                        <button class="feedback-type-btn" data-type="feature" style="padding: 0.75rem; border: 2px solid var(--border-light); border-radius: 6px; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s; font-size: 0.875rem;">
                            üí° Feature Request
                        </button>
                        <button class="feedback-type-btn" data-type="praise" style="padding: 0.75rem; border: 2px solid var(--border-light); border-radius: 6px; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s; font-size: 0.875rem;">
                            ‚ù§Ô∏è Something Works
                        </button>
                        <button class="feedback-type-btn" data-type="other" style="padding: 0.75rem; border: 2px solid var(--border-light); border-radius: 6px; background: var(--bg-secondary); cursor: pointer; transition: all 0.2s; font-size: 0.875rem;">
                            üí¨ General
                        </button>
                    </div>
                </div>
                
                <!-- Feedback Text -->
                <div style="margin-bottom: 1.5rem;">
                    <label for="feedbackText" class="form-label">Details:</label>
                    <textarea 
                        id="feedbackText" 
                        class="form-input"
                        rows="6"
                        placeholder="Be specific! What happened? What did you expect?&#10;&#10;For bugs: Steps to reproduce help.&#10;For features: What problem would this solve?"
                        style="resize: vertical; min-height: 150px; font-size: 14px;"
                    ></textarea>
                </div>
                
                <!-- Email (Optional) -->
                <div style="margin-bottom: 1.5rem;">
                    <label for="feedbackEmail" class="form-label">Your email (optional - for replies)</label>
                    <input 
                        type="email" 
                        id="feedbackEmail" 
                        class="form-input"
                        placeholder="your.email@example.com"
                    >
                </div>
                
                <!-- Submit Buttons -->
                <div style="display: flex; gap: 1rem;">
                    <button 
                        class="btn btn-secondary" 
                        onclick="closeFeedbackModal()"
                        style="flex: 1;"
                    >
                        Cancel
                    </button>
                    <button 
                        class="btn btn-primary" 
                        onclick="submitFeedback()"
                        id="feedbackSubmitBtn"
                        style="flex: 2;"
                    >
                        Send Feedback
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Morning Reflection Modal -->
    <div id="morningModal" class="modal-overlay hidden">
        <div class="modal morning-modal">
            <div class="modal-header">
                <h2>üåÖ Morning Reflection</h2>
            </div>
            
            <div class="modal-body">
                <div class="reflection-content" id="reflectionContent">
                    <p class="reflection-headline" style="font-family: 'Courier New', monospace; font-size: 0.75rem; font-weight: 700; color: var(--industrial-orange); letter-spacing: 1.5px; margin-bottom: 1rem; text-align: center;">MONASTIC DISCIPLINE</p>
                    <p class="reflection-text" style="font-size: 1.125rem; line-height: 1.8; color: var(--text-primary); font-weight: 400; font-style: italic;">
                        The day stretches before you like an empty canvas. What you choose to place on it reflects not just your plans, but your character. Discipline is not a burden placed upon you by others‚Äîit is the gift you give to your future self. Today, you have the power to honor your commitments or to excuse your failures. Choose deliberately.
                    </p>
                </div>
                
                <button id="generateReflection" class="btn btn-secondary" style="width: 100%; margin: 1rem 0;">Generate New Reflection</button>
                
                <div class="morning-note">
                    <strong>Remember:</strong> This is direction, not motivation. Reflect on it, then get to work.
                </div>
            </div>
            
            <div class="modal-footer">
                <button id="closeMorningBtn" class="btn btn-primary">Begin Day</button>
            </div>
        </div>
    </div>

    <!-- Mobile Task Action Bottom Sheet -->
    <div id="mobileActionSheet" class="mobile-action-sheet hidden">
        <div class="action-sheet-overlay"></div>
        <div class="action-sheet-content">
            <div class="action-sheet-header">
                <div class="action-sheet-handle"></div>
                <h3 id="actionSheetTaskName">Task Actions</h3>
            </div>
            
            <div class="action-sheet-body">
                <!-- Move To Section -->
                <div class="action-section">
                    <div class="action-section-label">Move To</div>
                    <button class="action-btn" data-action="move" data-bucket="holding">
                        <span class="action-icon">üìã</span>
                        <span class="action-label">Holding Area</span>
                    </button>
                    <button class="action-btn" data-action="move" data-bucket="urgent">
                        <span class="action-icon">üî•</span>
                        <span class="action-label">Admin</span>
                        <span class="action-meta">(1 sprint)</span>
                    </button>
                    <button class="action-btn" data-action="move" data-bucket="deepwork">
                        <span class="action-icon">üéØ</span>
                        <span class="action-label">Deep Work</span>
                        <span class="action-meta">(2 sprints)</span>
                    </button>
                    <button class="action-btn" data-action="move" data-bucket="strategic">
                        <span class="action-icon">‚ôüÔ∏è</span>
                        <span class="action-label">Strategic</span>
                        <span class="action-meta">(3 sprints)</span>
                    </button>
                </div>
                
                <!-- Priority Section -->
                <div class="action-section">
                    <div class="action-section-label">Priority</div>
                    <button class="action-btn" data-action="priority" data-priority="high">
                        <span class="action-icon">üî¥</span>
                        <span class="action-label">High Priority</span>
                        <span class="action-meta">(1.5x value)</span>
                    </button>
                    <button class="action-btn" data-action="priority" data-priority="medium">
                        <span class="action-icon">üü°</span>
                        <span class="action-label">Medium Priority</span>
                        <span class="action-meta">(1x value)</span>
                    </button>
                    <button class="action-btn" data-action="priority" data-priority="low">
                        <span class="action-icon">üü¢</span>
                        <span class="action-label">Low Priority</span>
                        <span class="action-meta">(0.5x value)</span>
                    </button>
                </div>
                
                <!-- Sprint Adjustment Section -->
                <div class="action-section" id="sprintAdjustSection">
                    <div class="action-section-label">Sprint Value</div>
                    <div class="sprint-adjuster">
                        <button class="sprint-adjust-btn" data-action="sprint" data-delta="-1">
                            <span style="font-size: 24px;">‚àí</span>
                        </button>
                        <div class="sprint-value-display">
                            <span id="actionSheetSprintValue">1</span>
                            <span style="font-size: 12px; color: var(--text-secondary);">sprints</span>
                        </div>
                        <button class="sprint-adjust-btn" data-action="sprint" data-delta="1">
                            <span style="font-size: 24px;">+</span>
                        </button>
                    </div>
                </div>
                
                <!-- Delete Section -->
                <div class="action-section">
                    <button class="action-btn action-btn-danger" data-action="delete">
                        <span class="action-icon">üóëÔ∏è</span>
                        <span class="action-label">Delete Task</span>
                    </button>
                </div>
                
                <!-- Cancel Button -->
                <button class="action-btn-cancel" id="actionSheetCancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- End of Day Modal -->
    <div id="eodModal" class="modal-overlay hidden">
        <div class="modal eod-modal">
            <div class="modal-header">
                <h2>üìä End of Day Report</h2>
            </div>
            
            <div class="modal-body">
                <div class="day-stats">
                    <div class="stat-card">
                        <div class="stat-label">Sprints</div>
                        <div class="stat-value"><span id="eodSprints">0</span> / <span id="eodPlanned">5</span></div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Tasks</div>
                        <div class="stat-value" id="eodTasks">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Distractions</div>
                        <div class="stat-value" id="eodDistractions">0</div>
                    </div>
                </div>

                <div class="grade-display">
                    <div class="grade-section">
                        <div class="grade-label">System Grade</div>
                        <div class="grade-value" id="systemGrade">-</div>
                    </div>
                    
                    <div class="grade-section">
                        <div class="grade-label">Your Grade</div>
                        <div class="grade-value" id="userGrade">-</div>
                        <div class="grade-selector">
                            <button class="grade-btn" data-grade="A+">A+</button>
                            <button class="grade-btn" data-grade="A">A</button>
                            <button class="grade-btn" data-grade="A-">A-</button>
                            <button class="grade-btn" data-grade="B+">B+</button>
                            <button class="grade-btn" data-grade="B">B</button>
                            <button class="grade-btn" data-grade="B-">B-</button>
                            <button class="grade-btn" data-grade="C+">C+</button>
                            <button class="grade-btn" data-grade="C">C</button>
                            <button class="grade-btn" data-grade="C-">C-</button>
                            <button class="grade-btn" data-grade="D+">D+</button>
                            <button class="grade-btn" data-grade="D">D</button>
                            <button class="grade-btn" data-grade="D-">D-</button>
                            <button class="grade-btn" data-grade="F">F</button>
                        </div>
                    </div>
                </div>

                <div class="reflection-section">
                    <label class="reflection-label">What went well? What could improve?</label>
                    <textarea id="reflectionInput" class="reflection-input" placeholder="Your thoughts..." rows="4"></textarea>
                </div>

                <div class="eod-note">
                    ‚ÑπÔ∏è Unfinished tasks and distractions will remain for tomorrow
                </div>
            </div>
            
            <div class="modal-footer">
                <button id="completeDayBtn" class="btn btn-primary">Complete Day</button>
            </div>
        </div>
    </div>

    <!-- Mode Configuration System -->
    <script src="config.js"></script>

    <!-- Analytics System -->
    <script src="analytics.js"></script>
    
    <!-- Keyboard Shortcuts -->
    <script src="keyboard-shortcuts.js"></script>

    <script>
        // ============================================
        // LOCALSTORAGE AUTHENTICATION CHECK
        // ============================================
        
        // Check if user is logged in (Supabase)
        async function checkAuthAndInit() {
            const user = await getCurrentUser()
            
            if (!user) {
                // Not logged in, redirect to start page
                window.location.href = 'start.html'
                return
            }
            
            // User is authenticated
            console.log('‚úÖ User authenticated:', user.email)
            
            // Ensure user profile exists (creates if missing)
            await ensureUserProfile();
            
            // Load user profile and set mode
            const { data: profile, error: profileError } = await supabaseClient
                .from('user_profiles')
                .select('mode, student_submode, theme')
                .eq('id', user.id)
                .maybeSingle()
            
            if (profileError) {
                console.warn('User profile query error:', profileError)
            }
            
            if (profile) {
                localStorage.setItem('focushub_mode', profile.mode)
                if (profile.student_submode) {
                    localStorage.setItem('focushub_student_submode', profile.student_submode)
                }
                if (profile.theme) {
                    localStorage.setItem('focushub_theme', profile.theme)
                }
            } else {
                // Set defaults if no profile exists yet
                localStorage.setItem('focushub_mode', 'professional')
                console.log('Using default mode: professional')
            }
            
            // Initialize the app
            init()
        }
        
        // User logout function
        window.handleFirebaseLogout = async function() {
            if (confirm('Are you sure you want to logout?')) {
                await signOut()
            }
        }
        
        // Start the app
        checkAuthAndInit()
    </script>
    
    <script>
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        // Data version for migration tracking
        const DATA_VERSION = 1;
        const APP_VERSION = '1.0.0';
        
        const state = {
            energyLevel: 'medium',
            baselineSprints: 5,
            plannedSprints: 5,
            sprintCount: 0,
            breaksCount: 0,
            distractionCount: 0,
            tasksCompleted: 0,
            meetingMinutes: 0,
            toughLoveLevel: 'balanced',
            timer: {
                timeLeft: 0,
                duration: 0,
                isRunning: false,
                timerType: 'focus',
                interval: null,
                endTime: null  // NEW: Track when timer should end
            },
            meeting: {
                active: false,
                startTime: null
            },
            tasks: {
                holding: [],
                urgent: [],
                deepwork: [],
                strategic: [],
                wins: []
            },
            distractions: [],
            intentions: [],
            taskHistory: [],  // NEW: Detailed task completion history
            currentSprintTask: null  // NEW: Track which task user is working on
        };

        const TASK_WEIGHTS = {
            strategic: 3,
            deepwork: 2,
            urgent: 1,
            holding: 0
        };

        const ENERGY_DURATIONS = {
            high: 30,   // Full Power ‚Üí Can handle 30 min sprints
            medium: 20, // Kinda Meh ‚Üí 20 min sprints
            low: 15     // On Fumes ‚Üí Short 15 min sprints
        };

        // ============================================
        // PRIVACY & DATA PROTECTION SYSTEM
        // ============================================
        
        // GDPR/CCPA Consent Banner
        function showConsentBanner() {
            // Check if user already consented
            if (localStorage.getItem('focushub_consent')) return;
            
            const banner = document.createElement('div');
            banner.id = 'consentBanner';
            banner.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--bg-secondary);
                border-top: 2px solid var(--accent-blue);
                padding: 1.5rem;
                z-index: 10000;
                box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            `;
            
            banner.innerHTML = `
                <div style="max-width: 1200px; margin: 0 auto;">
                    <p style="margin: 0 0 1rem 0; color: var(--text-primary); line-height: 1.5;">
                        <strong>Privacy Notice:</strong> FocusHub stores your tasks locally and optionally syncs to secure servers. 
                        <strong>Task text is automatically deleted every Friday</strong> to protect your privacy. 
                        <a href="/privacy.html" style="color: var(--accent-blue); text-decoration: underline;">Privacy Policy</a>
                    </p>
                    <button onclick="acceptConsent()" class="btn btn-primary" style="margin-right: 1rem;">
                        Accept & Continue
                    </button>
                    <button onclick="declineConsent()" class="btn" style="background: var(--bg-primary); border: 1px solid var(--border-light);">
                        Decline (Local Only)
                    </button>
                </div>
            `;
            
            document.body.appendChild(banner);
        }
        
        function acceptConsent() {
            localStorage.setItem('focushub_consent', Date.now());
            localStorage.setItem('focushub_consent_version', '1.0');
            localStorage.setItem('focushub_consent_type', 'full');
            document.getElementById('consentBanner')?.remove();
            console.log('‚úÖ Privacy consent accepted');
        }
        
        function declineConsent() {
            // User declines cloud sync but can use app locally
            localStorage.setItem('focushub_consent', Date.now());
            localStorage.setItem('focushub_consent_version', '1.0');
            localStorage.setItem('focushub_consent_type', 'local_only');
            document.getElementById('consentBanner')?.remove();
            alert('Local-only mode enabled. Your data will only be stored on this device.');
            console.log('‚úÖ Privacy consent: Local-only mode');
        }
        
        // Weekly Task Cleanup (GDPR Data Minimization)
        function weeklyTaskCleanup() {
            const now = new Date();
            const dayOfWeek = now.getDay(); // 0 = Sunday, 5 = Friday
            const hour = now.getHours();
            
            // Check if cleanup already ran this week
            const lastCleanup = localStorage.getItem('focushub_last_cleanup');
            const lastCleanupDate = lastCleanup ? new Date(parseInt(lastCleanup)) : null;
            
            // Run Friday at 11:59 PM or later
            if (dayOfWeek === 5 && hour === 23) {
                // Check if already ran this week
                if (lastCleanupDate) {
                    const daysSinceCleanup = Math.floor((now - lastCleanupDate) / (1000 * 60 * 60 * 24));
                    if (daysSinceCleanup < 7) {
                        return; // Already cleaned up this week
                    }
                }
                
                performWeeklyCleanup();
            }
        }
        
        function performWeeklyCleanup() {
            console.log('üßπ Running weekly privacy cleanup...');
            
            // Archive aggregated stats (no PII)
            const weeklyStats = {
                week: getWeekNumber(new Date()),
                year: new Date().getFullYear(),
                tasksCompleted: state.tasksCompleted,
                sprintsCompleted: state.sprintCount,
                breaksCount: state.breaksCount,
                avgEfficiency: calculateAvgEfficiency(),
                timestamp: Date.now()
            };
            
            // Get existing archived stats
            let archivedStats = [];
            try {
                const stored = localStorage.getItem('focushub_archived_stats');
                if (stored) archivedStats = JSON.parse(stored);
            } catch (e) {
                archivedStats = [];
            }
            
            // Add this week's stats
            archivedStats.push(weeklyStats);
            
            // Keep only last 90 days (approximately 13 weeks)
            if (archivedStats.length > 13) {
                archivedStats = archivedStats.slice(-13);
            }
            
            // Save archived stats
            localStorage.setItem('focushub_archived_stats', JSON.stringify(archivedStats));
            
            // DELETE all task text and PII
            state.tasks = getDefaultTaskStructure();
            state.taskHistory = [];
            state.distractions = [];
            
            // Save cleaned state
            saveState();
            
            // Mark cleanup complete
            localStorage.setItem('focushub_last_cleanup', Date.now().toString());
            
            console.log('‚úÖ Weekly cleanup complete: Task text deleted, stats archived');
            
            // Optional: Notify user
            if (state.tasksCompleted > 0) {
                console.log(`üìä Archived: ${state.tasksCompleted} tasks completed this week`);
            }
        }
        
        function getWeekNumber(date) {
            const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
            const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
            return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
        }
        
        function calculateAvgEfficiency() {
            const completedTasks = state.tasks?.wins || [];
            const tasksWithData = completedTasks.filter(t => 
                t.actualSprints > 0 && t.estimatedSprints > 0
            );
            
            if (tasksWithData.length === 0) return 1;
            
            return tasksWithData.reduce((sum, t) => {
                return sum + (t.estimatedSprints / t.actualSprints);
            }, 0) / tasksWithData.length;
        }
        
        function startWeeklyCleanupChecker() {
            // Check on startup
            weeklyTaskCleanup();
            
            // Check every hour
            setInterval(weeklyTaskCleanup, 3600000);
            
            console.log('üîí Weekly privacy cleanup checker started');
        }
        
        // Enhanced Data Export (GDPR Article 15)
        function exportAllUserData() {
            const timestamp = new Date().toISOString();
            
            const exportData = {
                export_info: {
                    exported_at: timestamp,
                    app_version: APP_VERSION,
                    data_version: DATA_VERSION,
                    user_email: '[Email from auth system]' // Will be populated by Supabase
                },
                current_data: {
                    tasks: state.tasks,
                    task_history: state.taskHistory || [],
                    distractions: state.distractions || [],
                    intentions: state.intentions || []
                },
                statistics: {
                    sprints_completed: state.sprintCount,
                    tasks_completed: state.tasksCompleted,
                    breaks_taken: state.breaksCount,
                    distractions_logged: state.distractionCount,
                    meeting_minutes: state.meetingMinutes
                },
                preferences: {
                    energy_level: state.energyLevel,
                    baseline_sprints: state.baselineSprints,
                    planned_sprints: state.plannedSprints,
                    tough_love_level: state.toughLoveLevel,
                    theme: localStorage.getItem('focushub_theme'),
                    mode: localStorage.getItem('focushub_mode')
                },
                archived_stats: JSON.parse(localStorage.getItem('focushub_archived_stats') || '[]')
            };
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
                type: 'application/json' 
            });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `focushub-data-export-${timestamp.split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('‚úÖ Data export complete');
            return exportData;
        }
        
        // Account Deletion (GDPR Article 17)
        async function deleteAllUserData() {
            const confirmed = confirm(
                '‚ö†Ô∏è DELETE ALL DATA?\n\n' +
                'This will permanently delete:\n' +
                '‚Ä¢ All your tasks and history\n' +
                '‚Ä¢ All statistics and progress\n' +
                '‚Ä¢ Your account and preferences\n\n' +
                'This action CANNOT be undone.\n\n' +
                'Are you absolutely sure?'
            );
            
            if (!confirmed) return;
            
            // Second confirmation
            const doubleCheck = confirm(
                'FINAL CONFIRMATION\n\n' +
                'Type YES below to confirm deletion.\n\n' +
                'This is your last chance to back out.'
            );
            
            if (!doubleCheck) return;
            
            console.log('üóëÔ∏è Deleting all user data...');
            
            // Delete from Supabase (if functions exist)
            try {
                if (typeof deleteUserAccount === 'function') {
                    await deleteUserAccount();
                    console.log('‚úÖ Deleted from Supabase');
                }
            } catch (error) {
                console.error('Supabase deletion error:', error);
            }
            
            // Delete all localStorage data
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith('focushub_')) {
                    localStorage.removeItem(key);
                }
            });
            
            console.log('‚úÖ All data deleted');
            
            // Sign out and redirect
            alert('All your data has been permanently deleted. You will now be signed out.');
            window.location.href = '/index.html';
        }
        
        // Age Verification (for Student Mode - COPPA/GDPR compliance)
        function verifyAgeForStudentMode() {
            const verified = localStorage.getItem('focushub_age_verified');
            if (verified) return true;
            
            const response = confirm(
                'Student Mode Age Verification\n\n' +
                'Student Mode is intended for students age 16 and older.\n\n' +
                'If you are under 16, you need parent/guardian permission to use this feature.\n\n' +
                'Click OK to confirm you are 16+ or have parent permission.\n' +
                'Click Cancel to use Professional Mode instead.'
            );
            
            if (response) {
                localStorage.setItem('focushub_age_verified', 'true');
                localStorage.setItem('focushub_age_verified_date', Date.now().toString());
                return true;
            }
            
            return false;
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            // DATA PROTECTION: Check versions and validate data
            checkDataVersion();
            checkAppVersion();
            validateAndRepairData();
            
            // Apply mode configuration FIRST
            applyModeConfig();
            
            // CHECK FOR NEW DAY *BEFORE* LOADING STATE
            checkForNewDayBeforeLoad();
            
            await loadState();
            restoreTimer();
            setupEventListeners();
            initDragDrop();
            checkSessionState();
            
            // Check premium status and show/hide reflection selector
            await checkPremiumStatus();
            
            // Remove unwanted duration buttons added by config.js
            removeExtraButtons();
            
            // Check and show first-run helpers
            checkFirstRunState();
            
            // Check for daily first-run prompt
            checkDailyFirstRun();
            
            // Update current task display
            updateCurrentTaskDisplay();
            
            // PRIVACY: Show consent banner on first visit
            showConsentBanner();
            
            // PRIVACY: Start weekly cleanup checker
            startWeeklyCleanupChecker();
            
            // PROACTIVE AI: Start intelligent coaching system
            startProactiveAICoach();
            
            // AUTO-CLEAR: Check for new day every 5 minutes
            startNewDayChecker();
            
            // Track user activity for idle detection
            document.addEventListener('click', trackUserActivity);
            document.addEventListener('keydown', trackUserActivity);
            document.addEventListener('mousemove', throttle(trackUserActivity, 30000)); // Throttle to every 30 seconds
        }
        
        // Throttle function to prevent excessive calls
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }
        
        function removeExtraButtons() {
            // Remove 25 and 45 minute buttons if config.js adds them
            setTimeout(() => {
                const extraButtons = document.querySelectorAll('.duration-btn[data-duration="25"], .duration-btn[data-duration="45"]');
                extraButtons.forEach(btn => btn.remove());
            }, 100);
        }
        
        // ============================================
        // DATA PERSISTENCE ENHANCEMENTS
        // ============================================
        
        function checkDataVersion() {
            const savedVersion = parseInt(localStorage.getItem('focushub_data_version') || '0');
            
            if (savedVersion < DATA_VERSION) {
                console.log(`üì¶ Migrating data from v${savedVersion} to v${DATA_VERSION}`);
                migrateData(savedVersion, DATA_VERSION);
            }
            
            // Always save current version
            localStorage.setItem('focushub_data_version', DATA_VERSION);
        }
        
        function migrateData(fromVersion, toVersion) {
            // Future migrations go here
            // Example:
            // if (fromVersion === 0 && toVersion === 1) {
            //     // Add new field to tasks
            //     const tasks = JSON.parse(localStorage.getItem('focushub_tasks') || '{}');
            //     // ... migration logic
            // }
            
            console.log(`‚úÖ Migration complete: v${fromVersion} ‚Üí v${toVersion}`);
        }
        
        function validateTaskStructure(tasks) {
            // Validate task data integrity
            if (!tasks || typeof tasks !== 'object') {
                console.error('‚ùå Invalid tasks structure, resetting');
                return false;
            }
            
            // Check required buckets
            const requiredBuckets = ['holding', 'urgent', 'deepwork', 'strategic', 'wins'];
            for (const bucket of requiredBuckets) {
                if (!Array.isArray(tasks[bucket])) {
                    console.error(`‚ùå Missing or invalid bucket: ${bucket}`);
                    return false;
                }
            }
            
            return true;
        }
        
        function getDefaultTaskStructure() {
            return {
                holding: [],
                urgent: [],
                deepwork: [],
                strategic: [],
                wins: []
            };
        }
        
        // ============================================
        // AUTOMATIC BACKUP SYSTEM (Silent, Professional)
        // ============================================
        
        function autoBackup() {
            // Automatic rolling backup - keeps last 7 days
            // Runs silently on every save, user never sees it
            try {
                const today = new Date().toISOString().split('T')[0];
                
                // Create snapshot
                const snapshot = {
                    date: today,
                    timestamp: Date.now(),
                    tasks: localStorage.getItem('focushub_tasks'),
                    stats: localStorage.getItem('focushub_daily_stats'),
                    distractions: localStorage.getItem('focushub_distractions'),
                    intentions: localStorage.getItem('focushub_intentions'),
                    taskHistory: JSON.stringify(state.taskHistory || [])
                };
                
                // Get existing backups
                let backups = {};
                try {
                    const stored = localStorage.getItem('focushub_auto_backups');
                    if (stored) backups = JSON.parse(stored);
                } catch (e) {
                    backups = {};
                }
                
                // Add today's backup
                backups[today] = snapshot;
                
                // Keep only last 7 days
                const dates = Object.keys(backups).sort();
                if (dates.length > 7) {
                    const toDelete = dates.slice(0, dates.length - 7);
                    toDelete.forEach(date => delete backups[date]);
                }
                
                // Save silently
                localStorage.setItem('focushub_auto_backups', JSON.stringify(backups));
                
                // Log for debugging (user won't see this)
                console.log(`‚úÖ Auto-backup: ${Object.keys(backups).length} days stored`);
            } catch (error) {
                // Fail silently - never interrupt user experience
                console.error('Auto-backup error (non-critical):', error);
            }
        }
        
        function exportUserData() {
            // Create comprehensive backup
            const backup = {
                version: DATA_VERSION,
                appVersion: APP_VERSION,
                timestamp: new Date().toISOString(),
                data: {
                    tasks: localStorage.getItem('focushub_tasks'),
                    daily_stats: localStorage.getItem('focushub_daily_stats'),
                    history: localStorage.getItem('focushub_history'),
                    distractions: localStorage.getItem('focushub_distractions'),
                    intentions: localStorage.getItem('focushub_intentions'),
                    preferences: {
                        energy: localStorage.getItem('focushub_energy'),
                        baseline: localStorage.getItem('focushub_baseline'),
                        tough_love: localStorage.getItem('focushub_tough_love'),
                        mode: localStorage.getItem('focushub_mode'),
                        theme: localStorage.getItem('focushub_theme')
                    }
                }
            };
            
            // Download as JSON
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `focushub-backup-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            console.log('‚úÖ Data exported successfully');
            return backup;
        }
        
        function importUserData(backupData) {
            try {
                // Validate backup structure
                if (!backupData.version || !backupData.data) {
                    throw new Error('Invalid backup format');
                }
                
                // Restore data
                if (backupData.data.tasks) {
                    localStorage.setItem('focushub_tasks', backupData.data.tasks);
                }
                if (backupData.data.history) {
                    localStorage.setItem('focushub_history', backupData.data.history);
                }
                if (backupData.data.distractions) {
                    localStorage.setItem('focushub_distractions', backupData.data.distractions);
                }
                if (backupData.data.intentions) {
                    localStorage.setItem('focushub_intentions', backupData.data.intentions);
                }
                
                // Restore preferences
                if (backupData.data.preferences) {
                    const prefs = backupData.data.preferences;
                    if (prefs.energy) localStorage.setItem('focushub_energy', prefs.energy);
                    if (prefs.baseline) localStorage.setItem('focushub_baseline', prefs.baseline);
                    if (prefs.tough_love) localStorage.setItem('focushub_tough_love', prefs.tough_love);
                    if (prefs.mode) localStorage.setItem('focushub_mode', prefs.mode);
                    if (prefs.theme) localStorage.setItem('focushub_theme', prefs.theme);
                }
                
                console.log('‚úÖ Data imported successfully');
                return true;
            } catch (error) {
                console.error('‚ùå Import failed:', error);
                return false;
            }
        }
        
        function checkAppVersion() {
            const lastVersion = localStorage.getItem('focushub_app_version');
            
            if (lastVersion !== APP_VERSION) {
                console.log(`üéâ Updated from ${lastVersion || 'initial'} to ${APP_VERSION}`);
                
                // Could show "What's New" modal here in future
                // showUpdateModal(lastVersion, APP_VERSION);
                
                localStorage.setItem('focushub_app_version', APP_VERSION);
            }
        }
        
        function validateAndRepairData() {
            // Run validation on load
            try {
                const tasksData = localStorage.getItem('focushub_tasks');
                if (tasksData) {
                    const tasks = JSON.parse(tasksData);
                    if (!validateTaskStructure(tasks)) {
                        console.warn('‚ö†Ô∏è Corrupted task data detected, repairing...');
                        const defaultTasks = getDefaultTaskStructure();
                        localStorage.setItem('focushub_tasks', JSON.stringify(defaultTasks));
                    }
                }
            } catch (error) {
                console.error('‚ùå Data validation error:', error);
                // Initialize with defaults if parsing fails
                const defaultTasks = getDefaultTaskStructure();
                localStorage.setItem('focushub_tasks', JSON.stringify(defaultTasks));
            }
        }

        async function loadState() {
            const today = new Date().toDateString();
            
            // Try loading from Supabase FIRST (Phase 3)
            try {
                if (typeof loadAllTasks === 'function' && typeof getTodaySession === 'function') {
                    console.log('üîÑ Loading from Supabase...');
                    
                    // Load session data
                    const session = await getTodaySession();
                    if (session) {
                        state.energyLevel = session.energy_level || 'medium';
                        state.baselineSprints = session.baseline_sprints || 5;
                        state.plannedSprints = session.planned_sprints || 5;
                        state.sprintCount = session.sprints_completed || 0;
                        state.tasksCompleted = session.tasks_completed || 0;
                        state.breaksCount = session.breaks_taken || 0;
                        state.distractionCount = session.distractions_logged || 0;
                        state.meetingMinutes = session.meeting_minutes || 0;
                        state.sessionState = session.session_state || 'not_started';
                        state.currentGrade = session.current_grade || null;
                    }
                    
                    // Load tasks
                    const tasks = await loadAllTasks();
                    if (tasks) {
                        state.tasks = tasks;
                    }
                    
                    // Load distractions
                    const distractions = await loadAllDistractions();
                    if (distractions && distractions.length > 0) {
                        state.distractions = distractions;
                    }
                    
                    // Load intentions
                    const intentions = await loadAllIntentions();
                    if (intentions && intentions.length > 0) {
                        state.intentions = intentions;
                    }
                    
                    // Load preferences from localStorage (not synced)
                    const storedEnergy = localStorage.getItem('focushub_energy');
                    const storedBaseline = localStorage.getItem('focushub_baseline');
                    const storedToughLove = localStorage.getItem('focushub_tough_love');
                    
                    if (storedEnergy) state.energyLevel = storedEnergy;
                    if (storedBaseline) state.baselineSprints = parseInt(storedBaseline) || 5;
                    if (storedToughLove) state.toughLoveLevel = storedToughLove;
                    
                    console.log('‚úÖ Loaded from Supabase');
                    return; // Exit early - we got data from Supabase
                }
            } catch (error) {
                console.error('Supabase load error (falling back to localStorage):', error);
            }
            
            // FALLBACK to localStorage if Supabase fails
            console.log('üìÇ Loading from localStorage (fallback)...');
            
            const savedStats = localStorage.getItem('focushub_daily_stats');
            if (savedStats) {
                const stats = JSON.parse(savedStats);
                if (stats.date === today) {
                    state.sprintCount = stats.sprintCount || 0;
                    state.breaksCount = stats.breaksCount || 0;
                    state.distractionCount = stats.distractionCount || 0;
                    state.tasksCompleted = stats.tasksCompleted || 0;
                    state.meetingMinutes = stats.meetingMinutes || 0;
                    state.plannedSprints = stats.plannedSprints || 5;
                }
            }

            const savedTasks = localStorage.getItem('focushub_tasks');
            if (savedTasks) {
                try {
                    const tasks = JSON.parse(savedTasks);
                    if (validateTaskStructure(tasks)) {
                        state.tasks = tasks;
                    } else {
                        console.warn('‚ö†Ô∏è Invalid task structure, using defaults');
                        state.tasks = getDefaultTaskStructure();
                    }
                } catch (error) {
                    console.error('‚ùå Task parse error:', error);
                    state.tasks = getDefaultTaskStructure();
                }
            }

            const savedDistractions = localStorage.getItem('focushub_distractions');
            if (savedDistractions) {
                state.distractions = JSON.parse(savedDistractions);
            }

            const savedIntentions = localStorage.getItem('focushub_intentions');
            if (savedIntentions) {
                state.intentions = JSON.parse(savedIntentions);
            }
            
            const storedEnergy = localStorage.getItem('focushub_energy');
            const storedBaseline = localStorage.getItem('focushub_baseline');
            const storedToughLove = localStorage.getItem('focushub_tough_love');
            
            if (storedEnergy) state.energyLevel = storedEnergy;
            if (storedBaseline) state.baselineSprints = parseInt(storedBaseline) || 5;
            if (storedToughLove) state.toughLoveLevel = storedToughLove;
        }

        function restoreTimer() {
            const savedTimer = localStorage.getItem('focushub_timer');
            if (!savedTimer) return;
            
            const timerData = JSON.parse(savedTimer);
            
            // Check if timer was running
            if (timerData.isRunning && timerData.timeLeft > 0) {
                // Calculate elapsed time since last save
                const elapsed = Math.floor((Date.now() - timerData.lastUpdated) / 1000);
                const adjustedTimeLeft = Math.max(0, timerData.timeLeft - elapsed);
                
                if (adjustedTimeLeft > 0) {
                    // Restore timer state
                    state.timer.duration = timerData.duration;
                    state.timer.timeLeft = adjustedTimeLeft;
                    state.timer.isRunning = true;
                    state.timer.timerType = timerData.timerType;
                    // Set endTime based on adjusted time left
                    state.timer.endTime = Date.now() + (adjustedTimeLeft * 1000);
                    
                    // Update UI
                    document.getElementById('timerSetup').classList.add('hidden');
                    document.getElementById('timerActive').classList.remove('hidden');
                    
                    // Hide energy dropdown during active timer
                    const energySelect = document.getElementById('energySelect');
                    if (energySelect && energySelect.parentElement) {
                        energySelect.parentElement.style.display = 'none';
                    }
                    
                    // Update system state and title
                    const stateEl = document.getElementById('systemState');
                    if (timerData.timerType === 'focus') {
                        stateEl.textContent = 'Sprint active. Focus mode engaged.';
                        document.getElementById('timerTitle').textContent = 'üéØ SPRINT TIMER';
                    } else {
                        stateEl.textContent = 'Break active.';
                        document.getElementById('timerTitle').textContent = '‚òï BREAK TIME';
                    }
                    
                    // Resume countdown
                    state.timer.interval = setInterval(updateTimer, 1000);
                    renderTimer();
                } else {
                    // Timer expired while away, complete it
                    if (timerData.timerType === 'focus') {
                        state.sprintCount++;
                        showCompletionCelebration();
                        updateBreakButton();
                    } else {
                        state.breaksCount++;
                    }
                    saveState();
                }
            }
        }

        async function saveState() {
            const today = new Date().toDateString();
            
            const stats = {
                sprintCount: state.sprintCount,
                breaksCount: state.breaksCount,
                distractionCount: state.distractionCount,
                tasksCompleted: state.tasksCompleted,
                meetingMinutes: state.meetingMinutes,
                plannedSprints: state.plannedSprints,
                date: today
            };
            
            // Save to Supabase FIRST (Phase 3)
            try {
                if (typeof saveAllTasks === 'function' && typeof saveTodaySession === 'function') {
                    // Save session data
                    await saveTodaySession({
                        energy_level: state.energyLevel,
                        baseline_sprints: state.baselineSprints,
                        planned_sprints: state.plannedSprints,
                        sprints_completed: state.sprintCount,
                        tasks_completed: state.tasksCompleted,
                        breaks_taken: state.breaksCount,
                        distractions_logged: state.distractionCount,
                        meeting_minutes: state.meetingMinutes,
                        session_state: state.sessionState,
                        current_grade: state.currentGrade
                    });
                    
                    // Save all tasks
                    await saveAllTasks(state.tasks);
                    
                    // Save all distractions
                    await saveAllDistractions(state.distractions);
                    
                    // Save all intentions
                    await saveAllIntentions(state.intentions);
                    
                    console.log('‚úÖ Saved to Supabase');
                }
            } catch (error) {
                console.error('Supabase save error (will use localStorage):', error);
            }
            
            // ALSO save to localStorage as backup/offline cache
            localStorage.setItem('focushub_daily_stats', JSON.stringify(stats));
            localStorage.setItem('focushub_tasks', JSON.stringify(state.tasks));
            localStorage.setItem('focushub_distractions', JSON.stringify(state.distractions));
            localStorage.setItem('focushub_intentions', JSON.stringify(state.intentions));
            localStorage.setItem('focushub_energy', state.energyLevel);
            localStorage.setItem('focushub_baseline', state.baselineSprints.toString());
            localStorage.setItem('focushub_tough_love', state.toughLoveLevel);
            
            // Save data version
            localStorage.setItem('focushub_data_version', DATA_VERSION);
            
            // AUTOMATIC ROLLING BACKUP: Keep last 7 days silently
            autoBackup();
            
            // Save timer state (local only)
            const timerState = {
                timeLeft: state.timer.timeLeft,
                duration: state.timer.duration,
                isRunning: state.timer.isRunning,
                timerType: state.timer.timerType,
                lastUpdated: Date.now()
            };
            localStorage.setItem('focushub_timer', JSON.stringify(timerState));
        }

        async function checkPremiumStatus() {
            try {
                // Check if user has premium access
                const hasPremium = await isPremiumUser();
                const reflectionGroup = document.getElementById('reflectionTraditionGroup');
                const reflectionSelect = document.getElementById('reflectionTraditionSelect');
                
                if (hasPremium) {
                    // Show reflection selector for premium users
                    if (reflectionGroup) {
                        reflectionGroup.style.display = 'block';
                    }
                    
                    // Load user's saved tradition preference
                    const savedTradition = await getReflectionTradition();
                    if (reflectionSelect && savedTradition) {
                        reflectionSelect.value = savedTradition;
                    }
                    
                    // Listen for changes
                    if (reflectionSelect) {
                        reflectionSelect.addEventListener('change', async (e) => {
                            const newTradition = e.target.value;
                            await setReflectionTradition(newTradition);
                            console.log(`‚úÖ Reflection tradition changed to: ${newTradition}`);
                        });
                    }
                } else {
                    // Hide for free users
                    if (reflectionGroup) {
                        reflectionGroup.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error checking premium status:', error);
            }
        }

        function checkForNewDayBeforeLoad() {
            const today = new Date().toDateString();
            const lastDate = localStorage.getItem('focushub_session_date');
            
            if (lastDate && lastDate !== today) {
                console.log('üåÖ NEW DAY DETECTED DURING INIT - Clearing old data BEFORE load');
                
                // Clear all counter data from localStorage
                const stats = {
                    sprintCount: 0,
                    breaksCount: 0,
                    distractionCount: 0,
                    tasksCompleted: 0,
                    meetingMinutes: 0,
                    plannedSprints: 5,
                    date: today
                };
                localStorage.setItem('focushub_daily_stats', JSON.stringify(stats));
                
                // Clear wins from tasks
                const savedTasks = localStorage.getItem('focushub_tasks');
                if (savedTasks) {
                    try {
                        const tasks = JSON.parse(savedTasks);
                        tasks.wins = []; // Clear wins
                        
                        // Move uncompleted priority tasks to holding
                        const bucketsToReset = ['urgent', 'deepwork', 'strategic'];
                        bucketsToReset.forEach(bucket => {
                            if (tasks[bucket]) {
                                const uncompletedTasks = tasks[bucket].filter(task => !task.completed);
                                uncompletedTasks.forEach(task => {
                                    task.bucket = 'holding';
                                    task.sprints = 0;
                                    task.actualSprints = 0;
                                    task.estimatedSprints = 0;
                                    tasks.holding.push(task);
                                });
                                tasks[bucket] = []; // Clear the bucket
                            }
                        });
                        
                        localStorage.setItem('focushub_tasks', JSON.stringify(tasks));
                    } catch (error) {
                        console.error('Error resetting tasks:', error);
                    }
                }
                
                // Clear distractions and intentions for new day
                localStorage.setItem('focushub_distractions', JSON.stringify([]));
                localStorage.setItem('focushub_intentions', JSON.stringify([]));
                
                // Reset session state to not_started
                localStorage.setItem('focushub_session_state', 'not_started');
                
                // Update session date
                localStorage.setItem('focushub_session_date', today);
                
                console.log('‚úÖ All counters reset for new day');
            }
        }
        
        function checkSessionState() {
            const sessionState = localStorage.getItem('focushub_session_state');
            const today = new Date().toDateString();
            const lastDate = localStorage.getItem('focushub_session_date');

            if (lastDate !== today) {
                // New day - perform daily reset AUTOMATICALLY
                console.log('üåÖ New day detected! Auto-clearing wins and resetting...');
                performDailyReset();
                localStorage.setItem('focushub_session_state', 'not_started');
                localStorage.setItem('focushub_session_date', today);
                showStartScreen();
            } else if (sessionState === 'active') {
                hideStartScreen();
                renderAll();
            } else {
                showStartScreen();
            }
        }
        
        // Periodic new-day checker (runs every 5 minutes)
        function startNewDayChecker() {
            setInterval(() => {
                const today = new Date().toDateString();
                const lastDate = localStorage.getItem('focushub_session_date');
                
                if (lastDate !== today) {
                    console.log('üåÖ Midnight passed! Auto-clearing wins and resetting...');
                    performDailyReset();
                    localStorage.setItem('focushub_session_date', today);
                    
                    // Show fresh start screen
                    const sessionState = localStorage.getItem('focushub_session_state');
                    if (sessionState === 'active') {
                        // User was working - notify them
                        alert('üåÖ New day! Your session has been reset. Wins cleared for a fresh start.');
                        showStartScreen();
                    }
                    
                    renderAll();
                }
            }, 300000); // Check every 5 minutes (300,000ms)
            
            console.log('‚è∞ New day checker started (checks every 5 minutes)');
        }
        
        function performDailyReset() {
            console.log('üîÑ Performing daily reset...');
            
            // Clear yesterday's wins
            state.tasks.wins = [];
            state.tasksCompleted = 0;
            
            // Reset sprint and break counts
            state.sprintCount = 0;
            state.breaksCount = 0;
            state.distractionCount = 0;
            
            // Move uncompleted tasks from priority buckets back to holding
            const bucketsToReset = ['urgent', 'deepwork', 'strategic'];
            
            bucketsToReset.forEach(bucket => {
                const uncompletedTasks = state.tasks[bucket].filter(task => !task.completed);
                
                // Move each uncompleted task to holding and reset sprints
                uncompletedTasks.forEach(task => {
                    task.bucket = 'holding';
                    task.sprints = 0; // Reset sprint weight
                    task.actualSprints = 0; // Reset sprint tracking
                    task.estimatedSprints = 0;
                    state.tasks.holding.push(task);
                });
                
                // Clear the bucket (wins already moved above)
                state.tasks[bucket] = [];
            });
            
            // Distractions persist (don't clear them)
            // Holding area persists (don't clear it)
            
            // Save the reset state
            saveState();
            
            console.log('‚úÖ Daily reset complete. Wins cleared, tasks moved to holding.');
        }

        // ============================================
        // START DAY SCREEN
        // ============================================
        function setupEventListeners() {
            // Start Day Screen
            document.querySelectorAll('.energy-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.energy-btn').forEach(b => b.classList.remove('active'));
                    e.currentTarget.classList.add('active');
                    state.energyLevel = e.currentTarget.dataset.energy;
                });
            });
            
            // Energy buttons in timer views (small buttons)
            // Energy level dropdown
            const energySelect = document.getElementById('energySelect');
            if (energySelect) {
                energySelect.addEventListener('change', (e) => {
                    state.energyLevel = e.target.value;
                    renderAll(); // Update recommended duration
                });
            }

            document.getElementById('decreaseBaseline').addEventListener('click', () => {
                const current = parseInt(document.getElementById('baselineValue').textContent);
                if (current > 0) {
                    document.getElementById('baselineValue').textContent = current - 1;
                }
            });

            document.getElementById('increaseBaseline').addEventListener('click', () => {
                const current = parseInt(document.getElementById('baselineValue').textContent);
                document.getElementById('baselineValue').textContent = current + 1;
            });

            document.getElementById('startDayBtn').addEventListener('click', startDay);

            // Timer controls
            document.querySelectorAll('.duration-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const timerType = e.currentTarget.dataset.type || 'focus';
                    let duration;
                    
                    if (timerType === 'break') {
                        // Smart break: 5 min for sprints 1-3, 15 min every 4th sprint
                        duration = (state.sprintCount > 0 && state.sprintCount % 4 === 0) ? 15 : 5;
                    } else {
                        duration = parseInt(e.currentTarget.dataset.duration);
                    }
                    
                    startTimer(duration, timerType);
                });
            });

            // Timer controls with null checks
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const confirmPauseBtn = document.getElementById('confirmPauseBtn');
            const cancelPauseBtn = document.getElementById('cancelPauseBtn');
            const completeBreakBtn = document.getElementById('completeBreakBtn');
            
            if (pauseBtn) pauseBtn.addEventListener('click', pauseTimer);
            if (resetBtn) resetBtn.addEventListener('click', resetTimer);
            if (confirmPauseBtn) confirmPauseBtn.addEventListener('click', confirmPause);
            if (cancelPauseBtn) cancelPauseBtn.addEventListener('click', cancelPause);
            if (completeBreakBtn) completeBreakBtn.addEventListener('click', completeBreak);

            // Meeting
            document.getElementById('meetingBtn').addEventListener('click', toggleMeeting);

            // Tasks
            document.getElementById('addTaskBtn').addEventListener('click', addTask);
            
            // Clear placeholder on paste
            const taskInput = document.getElementById('taskInput');
            if (taskInput) {
                taskInput.addEventListener('paste', (e) => {
                    // Clear placeholder attribute so it doesn't show through pasted text
                    setTimeout(() => {
                        if (taskInput.value.trim().length > 0) {
                            taskInput.placeholder = '';
                        }
                    }, 10);
                });
                
                // Restore placeholder when cleared
                taskInput.addEventListener('input', (e) => {
                    if (taskInput.value.trim().length === 0) {
                        taskInput.placeholder = 'What needs doing?';
                    }
                });
            }
            
            // Subject dropdown (student mode)
            const subjectSelect = document.getElementById('subjectSelect');
            if (subjectSelect) {
                subjectSelect.addEventListener('change', () => {
                    if (window.handleSubjectChange) {
                        handleSubjectChange();
                    }
                });
            }

            // Distractions
            document.getElementById('parkDistractionBtn').addEventListener('click', addDistraction);
            document.getElementById('distractionInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addDistraction();
            });

            // Tough Love
            // Tough love dropdown
            const toughLoveSelect = document.getElementById('toughLoveSelect');
            if (toughLoveSelect) {
                toughLoveSelect.addEventListener('change', (e) => {
                    state.toughLoveLevel = e.target.value;
                    saveState();
                    updateAgentMessage();
                });
            }
            
            // Logout
            document.getElementById('logoutBtn').addEventListener('click', () => {
                if (window.handleFirebaseLogout) {
                    window.handleFirebaseLogout();
                }
            });
            
            // End of Day
            document.getElementById('endDayBtn').addEventListener('click', showEndOfDayModal);
            document.querySelectorAll('.grade-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.grade-btn').forEach(b => b.classList.remove('selected'));
                    e.currentTarget.classList.add('selected');
                    document.getElementById('userGrade').textContent = e.currentTarget.dataset.grade;
                });
            });
            document.getElementById('completeDayBtn').addEventListener('click', completeDay);
        }

        function showStartScreen() {
            document.getElementById('startDayScreen').classList.remove('hidden');
            document.getElementById('mainApp').classList.add('hidden');
        }

        function hideStartScreen() {
            document.getElementById('startDayScreen').classList.add('hidden');
            document.getElementById('mainApp').classList.remove('hidden');
        }

        function startDay() {
            console.log('startDay called');
            state.baselineSprints = parseInt(document.getElementById('baselineValue').textContent);
            state.plannedSprints = state.baselineSprints;
            state.sessionState = 'active'; // FIX: Set session state
            
            console.log('Baseline sprints:', state.baselineSprints);
            
            // Save session state to localStorage (simple flag)
            localStorage.setItem('focushub_session_state', 'active');
            localStorage.setItem('focushub_session_date', new Date().toDateString());
            
            // Save to Supabase
            saveState();
            
            console.log('Hiding start screen...');
            hideStartScreen();
            
            console.log('Rendering all...');
            renderAll();
            updateAgentMessage();
            
            console.log('startDay complete');
        }

        // ============================================
        // TIMER
        // ============================================
        function startTimer(duration, timerType = 'focus') {
            // Clear any existing interval first
            if (state.timer.interval) {
                clearInterval(state.timer.interval);
            }
            
            state.timer.duration = duration * 60;
            state.timer.timeLeft = duration * 60;
            state.timer.isRunning = true;
            state.timer.timerType = timerType;
            state.timer.endTime = Date.now() + (duration * 60 * 1000);  // NEW: Set end timestamp

            document.getElementById('timerSetup').classList.add('hidden');
            document.getElementById('timerActive').classList.remove('hidden');
            
            // Hide energy dropdown during active timer
            const energySelect = document.getElementById('energySelect');
            if (energySelect && energySelect.parentElement) {
                energySelect.parentElement.style.display = 'none';
            }
            
            // Show/hide appropriate buttons based on timer type
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const completeBreakBtn = document.getElementById('completeBreakBtn');
            
            if (timerType === 'focus') {
                // Focus timer: show PAUSE and RESET
                if (pauseBtn) pauseBtn.classList.remove('hidden');
                if (resetBtn) resetBtn.classList.remove('hidden');
                if (completeBreakBtn) completeBreakBtn.classList.add('hidden');
            } else {
                // Break timer: hide PAUSE and RESET, show COMPLETE BREAK
                if (pauseBtn) pauseBtn.classList.add('hidden');
                if (resetBtn) resetBtn.classList.add('hidden');
                if (completeBreakBtn) completeBreakBtn.classList.remove('hidden');
            }
            
            // Update system state
            const stateEl = document.getElementById('systemState');
            if (timerType === 'focus') {
                stateEl.textContent = 'Sprint active. Focus mode engaged.';
                document.getElementById('timerTitle').textContent = 'üéØ SPRINT TIMER';
                
                // Trigger AI feedback immediately on sprint start
                generateAgentFeedback();
            } else {
                stateEl.textContent = 'Break active. Recharge and return.';
                document.getElementById('timerTitle').textContent = '‚òï BREAK TIME';
            }

            state.timer.interval = setInterval(updateTimer, 1000);
            
            // IMMEDIATELY render timer to show full duration (not 00:01)
            renderTimer();
            
            // Track sprint started
            if (window.FocusHubAnalytics) {
                FocusHubAnalytics.trackFeature('sprint_started', { duration: duration });
            }
        }

        function updateTimer() {
            if (!state.timer.isRunning || !state.timer.endTime) return;
            
            // Calculate time left based on endTime (timestamp-based, not setInterval-based)
            const now = Date.now();
            const timeLeftMs = state.timer.endTime - now;
            state.timer.timeLeft = Math.max(0, Math.ceil(timeLeftMs / 1000));
            
            if (state.timer.timeLeft > 0) {
                renderTimer();
                
                // Save timer state every 5 seconds for persistence
                if (state.timer.timeLeft % 5 === 0) {
                    saveState();
                }
            } else {
                completeTimer();
            }
        }

        function renderTimer() {
            const mins = Math.floor(state.timer.timeLeft / 60);
            const secs = state.timer.timeLeft % 60;
            document.getElementById('timerTime').textContent = 
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            
            const progress = ((state.timer.duration - state.timer.timeLeft) / state.timer.duration) * 100;
            document.getElementById('progressBar').style.width = progress + '%';
            
            // Update header timer if scrolled
            if (document.querySelector('.app-header').classList.contains('scrolled')) {
                updateHeaderTimer();
            }
        }

        function pauseTimer() {
            // Show confirmation instead of pausing immediately
            const pauseConfirm = document.getElementById('pauseConfirm');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (pauseConfirm && pauseBtn) {
                pauseConfirm.classList.remove('hidden');
                pauseBtn.disabled = true;
                pauseBtn.style.opacity = '0.5';
            }
        }
        
        function confirmPause() {
            // Actually pause after confirmation
            state.timer.isRunning = false;
            clearInterval(state.timer.interval);
            
            const pauseBtn = document.getElementById('pauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const pauseConfirm = document.getElementById('pauseConfirm');
            
            if (pauseBtn) {
                pauseBtn.textContent = '‚ñ∂ RESUME';
                pauseBtn.disabled = false;
                pauseBtn.style.opacity = '1';
                pauseBtn.style.background = 'var(--success)';
                // Change click handler to resume
                pauseBtn.onclick = resumeTimer;
            }
            
            if (pauseConfirm) {
                pauseConfirm.classList.add('hidden');
            }
            
            // Update system state
            document.getElementById('systemState').textContent = 'Sprint paused. Resume to continue.';
            saveState();
        }
        
        function cancelPause() {
            // User chose to keep going - hide confirmation
            const pauseConfirm = document.getElementById('pauseConfirm');
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (pauseConfirm) {
                pauseConfirm.classList.add('hidden');
            }
            
            if (pauseBtn) {
                pauseBtn.disabled = false;
                pauseBtn.style.opacity = '1';
            }
        }

        function resumeTimer() {
            // Clear any existing interval first
            if (state.timer.interval) {
                clearInterval(state.timer.interval);
            }
            
            state.timer.isRunning = true;
            // Recalculate endTime based on current timeLeft
            state.timer.endTime = Date.now() + (state.timer.timeLeft * 1000);
            state.timer.interval = setInterval(updateTimer, 1000);
            
            const pauseBtn = document.getElementById('pauseBtn');
            if (pauseBtn) {
                pauseBtn.textContent = '‚è∏ PAUSE';
                pauseBtn.style.background = 'var(--warning)';
                pauseBtn.style.color = '#1a1a1a';
                // Change click handler back to pause
                pauseBtn.onclick = pauseTimer;
            }
            
            // Update system state
            const timerType = state.timer.timerType;
            if (timerType === 'focus') {
                document.getElementById('systemState').textContent = 'Sprint active. Focus mode engaged.';
            } else {
                document.getElementById('systemState').textContent = 'Break active.';
            }
        }

        function resetTimer() {
            clearInterval(state.timer.interval);
            state.timer.timeLeft = 0;
            state.timer.isRunning = false;
            document.getElementById('timerSetup').classList.remove('hidden');
            document.getElementById('timerActive').classList.add('hidden');
            
            // Show energy dropdown again
            const energySelect = document.getElementById('energySelect');
            if (energySelect && energySelect.parentElement) {
                energySelect.parentElement.style.display = 'flex';
            }
            
            // Update system state
            document.getElementById('systemState').textContent = 'System idle. Start a sprint to begin.';
        }

        function completeTimer() {
            clearInterval(state.timer.interval);
            
            if (state.timer.timerType === 'focus') {
                state.sprintCount++;
                
                // Track sprint completion for current task
                if (state.currentSprintTask) {
                    trackSprintForTask(state.currentSprintTask);
                }
                
                // Show industrial completion celebration
                showCompletionCelebration();
                
                // Mark first session complete (first-run helper removal)
                if (state.sprintCount === 1) {
                    localStorage.setItem('focushub_first_session_complete', 'true');
                    hideFirstRunHelpers();
                }
                
                // Update break button based on Pomodoro rules
                updateBreakButton();
                
                // Show timer setup so user can choose break duration
                resetTimer();
            } else {
                // Break complete
                state.breaksCount++;
                resetTimer();
            }
            
            saveState();
            renderAll();
            updateAgentMessage();
        }
        
        function completeBreak() {
            // End break early but count it as full break
            if (state.timer.timerType === 'break') {
                clearInterval(state.timer.interval);
                state.breaksCount++;
                resetTimer();
                saveState();
                renderAll();
                updateAgentMessage();
            }
        }
        
        // ============================================
        // TASK SPRINT TRACKING
        // ============================================
        
        function trackSprintForTask(taskId) {
            // Find task across all buckets
            let task = null;
            let bucket = null;
            
            for (const b of ['urgent', 'deepwork', 'strategic', 'holding']) {
                const found = state.tasks[b].find(t => t.id === taskId);
                if (found) {
                    task = found;
                    bucket = b;
                    break;
                }
            }
            
            if (!task) return;
            
            // Initialize tracking fields if needed
            if (!task.actualSprints) task.actualSprints = 0;
            if (!task.sprintSessions) task.sprintSessions = [];
            if (!task.startedAt) task.startedAt = new Date().toISOString();
            if (!task.estimatedSprints) task.estimatedSprints = task.sprints || 0;
            
            // Increment actual sprints
            task.actualSprints++;
            
            // Record this sprint session
            task.sprintSessions.push({
                completedAt: new Date().toISOString(),
                sprintNumber: state.sprintCount,
                duration: state.timer.duration / 60  // minutes
            });
            
            // Save state
            saveState();
            
            // Update UI to reflect progress
            renderTasks();
        }
        
        function setCurrentTask(taskId) {
            state.currentSprintTask = taskId;
            saveState();
            updateCurrentTaskDisplay();
        }
        
        function clearCurrentTask() {
            state.currentSprintTask = null;
            saveState();
            updateCurrentTaskDisplay();
        }
        
        function updateCurrentTaskDisplay() {
            const display = document.getElementById('currentTaskDisplay');
            if (!display) return;
            
            if (state.currentSprintTask) {
                // Find the task
                let task = null;
                for (const b of ['urgent', 'deepwork', 'strategic', 'holding']) {
                    const found = state.tasks[b].find(t => t.id === state.currentSprintTask);
                    if (found) {
                        task = found;
                        break;
                    }
                }
                
                if (task) {
                    const actual = task.actualSprints || 0;
                    const estimated = task.estimatedSprints || task.sprints || 0;
                    const progress = estimated > 0 ? `${actual}/${estimated}` : `${actual}`;
                    
                    display.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 0.5rem;">
                            <span style="color: var(--accent-blue);">üéØ Working on:</span>
                            <strong>${task.text}</strong>
                            <span style="color: var(--text-secondary);">(${progress} sprints)</span>
                            <button onclick="clearCurrentTask()" style="padding: 0.25rem 0.5rem; font-size: 0.8rem;">Clear</button>
                        </div>
                    `;
                    display.classList.remove('hidden');
                } else {
                    display.classList.add('hidden');
                }
            } else {
                display.classList.add('hidden');
            }
        }

        // ============================================
        // MEETING TRACKER
        // ============================================
        function toggleMeeting() {
            if (state.meeting.active) {
                // End meeting
                const elapsed = Math.floor((Date.now() - state.meeting.startTime) / 1000 / 60);
                state.meetingMinutes += elapsed;
                state.meeting.active = false;
                state.meeting.startTime = null;
                document.getElementById('meetingBtn').textContent = 'üìÖ Meeting';
                document.getElementById('meetingTime').classList.add('hidden');
            } else {
                // Start meeting
                state.meeting.active = true;
                state.meeting.startTime = Date.now();
                document.getElementById('meetingBtn').textContent = 'üî¥ End Meeting';
                document.getElementById('meetingTime').classList.remove('hidden');
                
                // Update meeting time every minute
                setInterval(() => {
                    if (state.meeting.active) {
                        const elapsed = Math.floor((Date.now() - state.meeting.startTime) / 1000 / 60);
                        document.getElementById('meetingTime').textContent = elapsed + 'm';
                    }
                }, 60000);
            }
            saveState();
        }

        // ============================================
        // TASK MANAGEMENT WITH DRAG/DROP
        // ============================================
        
        let draggedTask = null;
        let draggedBucket = null;
        
        // Parse and add tasks from textarea
        function addTask() {
            const input = document.getElementById('taskInput');
            const text = input.value.trim();
            
            if (!text) return;
            
            // Get subject if in student mode
            const subjectSelect = document.getElementById('subjectSelect');
            const customSubjectInput = document.getElementById('customSubjectInput');
            let subject = null;
            let customSubject = null;
            
            if (subjectSelect && !subjectSelect.classList.contains('hidden')) {
                const selectedValue = subjectSelect.value;
                if (selectedValue && selectedValue !== 'custom') {
                    subject = selectedValue;
                } else if (selectedValue === 'custom' && customSubjectInput.value.trim()) {
                    customSubject = customSubjectInput.value.trim();
                    subject = customSubject; // Use custom as the display subject
                }
            }
            
            // Split by newlines and filter empty lines
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            lines.forEach(taskText => {
                const newTask = {
                    id: Date.now() + Math.random(),
                    text: taskText,
                    bucket: 'holding',
                    sprints: 0,
                    priority: 'medium', // Default priority
                    completed: false,
                    createdAt: new Date().toISOString(),
                    // Student mode fields (Phase 3)
                    subject: subject,
                    customSubject: customSubject,
                    deadline: null,
                    // NEW: Sprint tracking
                    actualSprints: 0,  // Sprints actually spent on this task
                    estimatedSprints: 0,  // Will be set when moved to bucket
                    startedAt: null,  // When user started working on it
                    sprintSessions: []  // Track each sprint session
                };
                
                state.tasks.holding.push(newTask);
            });
            
            input.value = '';
            // Clear subject selection
            if (subjectSelect) {
                subjectSelect.value = '';
            }
            if (customSubjectInput) {
                customSubjectInput.value = '';
                customSubjectInput.classList.add('hidden');
            }
            saveState();
            renderTasks();
        }
        
        // Create task element with all controls
        function createTaskElement(task, bucket) {
            const div = document.createElement('div');
            div.className = 'task-item';
            div.draggable = true;
            div.dataset.taskId = task.id;
            div.dataset.bucket = bucket;
            
            // Drag handle
            const dragHandle = document.createElement('span');
            dragHandle.className = 'task-drag-handle';
            dragHandle.textContent = '‚ãÆ‚ãÆ';
            
            // On mobile (< 768px), clicking handle opens bottom sheet
            // On desktop, it's for dragging
            dragHandle.addEventListener('click', (e) => {
                if (window.innerWidth < 768) {
                    e.stopPropagation();
                    showMobileActionSheet(task, bucket);
                }
            });
            
            div.appendChild(dragHandle);
            
            // Priority indicator (within bucket) - not in holding or wins
            if (bucket !== 'holding' && bucket !== 'wins') {
                const priorityIndicator = document.createElement('button');
                priorityIndicator.className = 'task-priority-indicator';
                priorityIndicator.title = 'Click to change priority';
                
                // Get task priority (default to medium if not set)
                const taskPriority = task.priority || 'medium';
                
                // Set color based on priority
                let priorityColor = 'üü°'; // Default medium
                if (taskPriority === 'high') priorityColor = 'üî¥';
                if (taskPriority === 'medium') priorityColor = 'üü°';
                if (taskPriority === 'low') priorityColor = 'üü¢';
                
                priorityIndicator.textContent = priorityColor;
                priorityIndicator.style.cssText = 'background: none; border: none; font-size: 18px; cursor: pointer; padding: 0; width: 24px; height: 24px;';
                
                // Click to cycle through priorities (stays in same bucket)
                priorityIndicator.addEventListener('click', (e) => {
                    e.stopPropagation(); // Don't trigger other clicks
                    
                    // Cycle: high ‚Üí medium ‚Üí low ‚Üí high
                    if (task.priority === 'high') task.priority = 'medium';
                    else if (task.priority === 'medium') task.priority = 'low';
                    else task.priority = 'high';
                    
                    saveState();
                    renderTasks();
                });
                
                div.appendChild(priorityIndicator);
            }
            
            // Sprint controls (not in holding or wins) - compact with triangles
            if (bucket !== 'holding' && bucket !== 'wins') {
                const sprintControls = document.createElement('div');
                sprintControls.className = 'task-sprint-controls';
                sprintControls.style.cssText = 'display: flex; align-items: center; gap: 2px; position: relative;';
                
                // Value (always visible)
                const sprintValue = document.createElement('span');
                sprintValue.className = 'task-sprint-value';
                sprintValue.textContent = task.sprints || 0;
                sprintValue.style.cssText = 'font-size: 12px; font-weight: 700; color: var(--text-primary); min-width: 16px; text-align: center; font-family: "Roboto Mono", monospace;';
                
                // Up button (hidden by default, shows on hover)
                const upBtn = document.createElement('button');
                upBtn.className = 'task-sprint-btn-compact';
                upBtn.textContent = '‚ñ≤';
                upBtn.style.cssText = 'background: none; border: none; color: var(--text-secondary); font-size: 8px; cursor: pointer; padding: 0; width: 12px; height: 10px; opacity: 0; transition: opacity 0.2s;';
                upBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    adjustTaskSprints(task.id, bucket, 1);
                });
                
                // Down button (hidden by default, shows on hover)
                const downBtn = document.createElement('button');
                downBtn.className = 'task-sprint-btn-compact';
                downBtn.textContent = '‚ñº';
                downBtn.style.cssText = 'background: none; border: none; color: var(--text-secondary); font-size: 8px; cursor: pointer; padding: 0; width: 12px; height: 10px; opacity: 0; transition: opacity 0.2s;';
                downBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    adjustTaskSprints(task.id, bucket, -1);
                });
                
                // Show buttons on hover
                sprintControls.addEventListener('mouseenter', () => {
                    upBtn.style.opacity = '1';
                    downBtn.style.opacity = '1';
                });
                sprintControls.addEventListener('mouseleave', () => {
                    upBtn.style.opacity = '0';
                    downBtn.style.opacity = '0';
                });
                
                sprintControls.appendChild(upBtn);
                sprintControls.appendChild(sprintValue);
                sprintControls.appendChild(downBtn);
                div.appendChild(sprintControls);
            }
            
            // Checkbox (only in active buckets, not holding or wins)
            if (bucket !== 'holding' && bucket !== 'wins') {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'task-checkbox';
                checkbox.checked = task.completed;
                checkbox.addEventListener('change', () => completeTask(bucket, task.id));
                div.appendChild(checkbox);
            }
            
            // Task text
            const textSpan = document.createElement('span');
            textSpan.className = bucket === 'wins' ? 'win-text' : 'task-text';
            textSpan.textContent = task.text;
            div.appendChild(textSpan);
            
            // Sprint progress indicator (if task is being worked on)
            if (bucket !== 'holding' && bucket !== 'wins' && task.actualSprints > 0) {
                const progressBadge = document.createElement('span');
                const actual = task.actualSprints;
                const estimated = task.estimatedSprints || task.sprints || 0;
                const isOnTrack = actual <= estimated;
                progressBadge.textContent = estimated > 0 ? `${actual}/${estimated}` : `${actual}`;
                progressBadge.style.cssText = `
                    display: inline-block;
                    margin-left: 0.5rem;
                    padding: 0.125rem 0.5rem;
                    background: ${isOnTrack ? 'var(--success)' : 'var(--warning)'};
                    color: white;
                    border-radius: 12px;
                    font-size: 0.75rem;
                    font-weight: 600;
                `;
                progressBadge.title = isOnTrack ? 'On track!' : 'Over estimate';
                div.appendChild(progressBadge);
            }
            
            // Subject badge (if subject exists)
            if (task.subject) {
                const subjectBadge = document.createElement('span');
                subjectBadge.className = 'task-subject-badge';
                subjectBadge.textContent = task.subject;
                subjectBadge.style.cssText = 'display: inline-block; margin-left: 0.5rem; padding: 0.125rem 0.5rem; background: var(--primary-color); color: white; border-radius: 12px; font-size: 0.75rem; font-weight: 600;';
                div.appendChild(subjectBadge);
            }
            
            // "Work on this" button (only in active buckets)
            if (bucket !== 'holding' && bucket !== 'wins') {
                const workBtn = document.createElement('button');
                const isCurrentTask = state.currentSprintTask === task.id;
                workBtn.textContent = isCurrentTask ? '‚úì' : '‚ñ∂';
                workBtn.title = isCurrentTask ? 'Currently working on this' : 'Work on this task';
                workBtn.style.cssText = `
                    padding: 0.25rem 0.5rem;
                    margin-left: 0.5rem;
                    font-size: 0.8rem;
                    background: ${isCurrentTask ? 'var(--success)' : 'var(--accent-blue)'};
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                workBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isCurrentTask) {
                        clearCurrentTask();
                    } else {
                        setCurrentTask(task.id);
                    }
                });
                div.appendChild(workBtn);
            }
            
            // Delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'task-delete';
            deleteBtn.textContent = '√ó';
            deleteBtn.addEventListener('click', () => deleteTask(bucket, task.id));
            div.appendChild(deleteBtn);
            
            // Drag events
            div.addEventListener('dragstart', handleDragStart);
            div.addEventListener('dragend', handleDragEnd);
            
            return div;
        }
        
        // Drag and drop handlers
        function handleDragStart(e) {
            draggedTask = e.target;
            draggedBucket = e.target.dataset.bucket;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over');
            });
            // Don't clear draggedTask/draggedBucket here - let handleDrop do it
            // Or clear after a small delay to ensure drop event fires first
            setTimeout(() => {
                draggedTask = null;
                draggedBucket = null;
            }, 50);
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const list = e.currentTarget;
            list.classList.add('drag-over');
            // Enhanced visual feedback
            list.style.background = 'rgba(37, 99, 235, 0.1)';
            list.style.borderColor = 'var(--accent-blue)';
        }
        
        function handleDragLeave(e) {
            const list = e.currentTarget;
            list.classList.remove('drag-over');
            // Remove visual feedback
            list.style.background = '';
            list.style.borderColor = '';
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            e.currentTarget.classList.remove('drag-over');
            const targetBucket = e.currentTarget.dataset.bucket;
            
            console.log('Drop detected:', { targetBucket, draggedTask, draggedBucket, draggedDistraction });
            
            // Check if dropping a distraction
            if (draggedDistraction) {
                // Convert distraction to task in ANY bucket
                const newTask = {
                    id: Date.now() + Math.random(),
                    text: draggedDistraction.text,
                    bucket: targetBucket,
                    sprints: targetBucket === 'holding' ? 0 : (TASK_WEIGHTS[targetBucket] || 1),
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                
                state.tasks[targetBucket].push(newTask);
                
                // Remove from distractions
                state.distractions = state.distractions.filter(d => d.id !== draggedDistraction.id);
                
                // Remove related intention if exists
                const intention = state.intentions.find(i => i.distractionId === draggedDistraction.id);
                if (intention) {
                    state.intentions = state.intentions.filter(i => i.distractionId !== draggedDistraction.id);
                }
                
                draggedDistraction = null;
                saveState();
                renderTasks();
                renderDistractions();
            }
            // Check if dropping a task
            else if (draggedTask && draggedBucket) {
                const taskId = parseFloat(draggedTask.dataset.taskId);
                console.log('Moving task:', { taskId, from: draggedBucket, to: targetBucket });
                
                if (taskId && draggedBucket && targetBucket) {
                    moveTask(taskId, draggedBucket, targetBucket);
                    // Clear dragged items
                    draggedTask = null;
                    draggedBucket = null;
                } else {
                    console.error('Missing data for task move:', { taskId, draggedBucket, targetBucket });
                }
            } else {
                console.warn('No valid drag data found');
            }
        }
        
        // Move task between buckets
        function moveTask(taskId, fromBucket, toBucket) {
            const taskIndex = state.tasks[fromBucket].findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            
            const task = state.tasks[fromBucket][taskIndex];
            state.tasks[fromBucket].splice(taskIndex, 1);
            
            task.bucket = toBucket;
            
            // Set default sprints based on bucket
            if (toBucket !== 'holding' && toBucket !== 'wins') {
                if (task.sprints === 0 || task.sprints === undefined) {
                    task.sprints = TASK_WEIGHTS[toBucket] || 0;
                }
                // Set estimated sprints if not already set
                if (!task.estimatedSprints) {
                    task.estimatedSprints = task.sprints;
                }
            }
            
            state.tasks[toBucket].push(task);
            
            saveState();
            renderTasks();
            updateSprintTarget();
            updateCurrentTaskDisplay();  // Update in case current task was moved
        }
        
        // Adjust sprint count for individual task
        function adjustTaskSprints(taskId, bucket, delta) {
            const task = state.tasks[bucket].find(t => t.id === taskId);
            if (!task) return;
            
            task.sprints = Math.max(0, (task.sprints || 0) + delta);
            // Update estimate when user manually adjusts
            task.estimatedSprints = task.sprints;
            
            saveState();
            renderTasks();
            updateSprintTarget();
        }
        
        // Complete task (move to wins)
        function completeTask(bucket, taskId) {
            const taskIndex = state.tasks[bucket].findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            
            const task = state.tasks[bucket][taskIndex];
            state.tasks[bucket].splice(taskIndex, 1);
            
            task.completed = true;
            task.bucket = 'wins';
            task.completedAt = new Date().toISOString();
            
            // Calculate efficiency metrics
            const estimatedSprints = task.estimatedSprints || task.sprints || 0;
            const actualSprints = task.actualSprints || 0;
            const efficiency = estimatedSprints > 0 ? (estimatedSprints / Math.max(actualSprints, 1)) : 1;
            const variance = actualSprints - estimatedSprints;
            
            // Create detailed completion record
            const completionRecord = {
                id: task.id,
                text: task.text,
                bucket: bucket,
                subject: task.subject,
                completedAt: task.completedAt,
                createdAt: task.createdAt,
                estimatedSprints: estimatedSprints,
                actualSprints: actualSprints,
                efficiency: efficiency,  // > 1 = faster than expected, < 1 = slower
                variance: variance,  // negative = beat estimate, positive = over estimate
                sprintSessions: task.sprintSessions || [],
                duration: task.startedAt ? 
                    Math.floor((new Date(task.completedAt) - new Date(task.startedAt)) / 1000 / 60) : 
                    null  // minutes
            };
            
            // Add to history
            state.taskHistory.push(completionRecord);
            
            // Keep only wins from today in tasks.wins for UI
            task.completionRecord = completionRecord;  // Store reference
            state.tasks.wins.push(task);
            
            state.tasksCompleted++;
            
            // Track with analytics
            if (window.FocusHubAnalytics) {
                FocusHubAnalytics.trackFeature('task_completed', {
                    bucket: bucket,
                    estimatedSprints: estimatedSprints,
                    actualSprints: actualSprints,
                    efficiency: efficiency.toFixed(2),
                    beatEstimate: variance < 0
                });
            }
            
            saveState();
            renderTasks();
            updateAgentMessage();
            
            // Show brief completion message if task beat estimate
            if (variance < 0) {
                console.log(`üéâ Completed "${task.text}" in ${actualSprints} sprints (estimated ${estimatedSprints})!`);
            }
        }
        
        // Delete task
        function deleteTask(bucket, taskId) {
            const taskIndex = state.tasks[bucket].findIndex(t => t.id === taskId);
            if (taskIndex === -1) return;
            
            state.tasks[bucket].splice(taskIndex, 1);
            saveState();
            renderTasks();
            updateSprintTarget();
        }
        
        // Render all tasks
        function renderTasks() {
            // Render holding area
            const holdingList = document.getElementById('holdingList');
            holdingList.innerHTML = '';
            state.tasks.holding.forEach(task => {
                holdingList.appendChild(createTaskElement(task, 'holding'));
            });
            document.getElementById('holdingCount').textContent = state.tasks.holding.length;
            
            // Render buckets
            ['urgent', 'deepwork', 'strategic'].forEach(bucket => {
                const list = document.getElementById(`${bucket}List`);
                list.innerHTML = '';
                state.tasks[bucket].forEach(task => {
                    list.appendChild(createTaskElement(task, bucket));
                });
                document.getElementById(`${bucket}Count`).textContent = state.tasks[bucket].length;
            });
            
            // Render wins
            const winsList = document.getElementById('winsList');
            const winsSection = document.getElementById('winsSection');
            
            if (state.tasks.wins.length > 0) {
                winsSection.classList.remove('hidden');
                winsList.innerHTML = '';
                state.tasks.wins.forEach(task => {
                    winsList.appendChild(createTaskElement(task, 'wins'));
                });
            } else {
                winsSection.classList.add('hidden');
            }
        }
        
        // Initialize drag/drop on all task lists
        function initDragDrop() {
            document.querySelectorAll('.task-list').forEach(list => {
                list.addEventListener('dragover', handleDragOver);
                list.addEventListener('dragleave', handleDragLeave);
                list.addEventListener('drop', handleDrop);
            });
        }
        
        // ============================================
        // MOBILE TOUCH DRAG & DROP SUPPORT
        // ============================================
        
        let touchStartX, touchStartY;
        let touchElement = null;
        let touchClone = null;
        let isDraggingTouch = false;
        
        function initTouchDragDrop() {
            // Only enable touch drag on tablets (768px+), not on phones
            // Phones use the bottom sheet action menu instead
            if (window.innerWidth < 768) {
                return; // Skip touch drag & drop on mobile phones
            }
            
            function addTouchEvents(element) {
                element.addEventListener('touchstart', handleTouchStart, { passive: false });
                element.addEventListener('touchmove', handleTouchMove, { passive: false });
                element.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
            
            document.querySelectorAll('.task-item').forEach(addTouchEvents);
            document.querySelectorAll('.distraction-item').forEach(addTouchEvents);
        }
        
        function handleTouchStart(e) {
            if (!e.target.classList.contains('task-drag-handle') && !e.target.closest('.task-drag-handle')) {
                return;
            }
            
            e.preventDefault();
            
            touchElement = e.target.closest('.task-item') || e.target.closest('.distraction-item');
            if (!touchElement) return;
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            
            touchClone = touchElement.cloneNode(true);
            touchClone.style.position = 'fixed';
            touchClone.style.zIndex = '9999';
            touchClone.style.opacity = '0.8';
            touchClone.style.pointerEvents = 'none';
            touchClone.style.width = touchElement.offsetWidth + 'px';
            touchClone.style.left = touch.clientX - (touchElement.offsetWidth / 2) + 'px';
            touchClone.style.top = touch.clientY - 30 + 'px';
            document.body.appendChild(touchClone);
            
            touchElement.style.opacity = '0.3';
            isDraggingTouch = true;
        }
        
        function handleTouchMove(e) {
            if (!isDraggingTouch || !touchClone) return;
            
            e.preventDefault();
            
            const touch = e.touches[0];
            touchClone.style.left = touch.clientX - (touchClone.offsetWidth / 2) + 'px';
            touchClone.style.top = touch.clientY - 30 + 'px';
            
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elementBelow?.closest('.task-list');
            
            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over');
            });
            
            if (dropZone) {
                dropZone.classList.add('drag-over');
            }
        }
        
        function handleTouchEnd(e) {
            if (!isDraggingTouch) return;
            
            e.preventDefault();
            
            const touch = e.changedTouches[0];
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropZone = elementBelow?.closest('.task-list');
            
            if (touchClone) {
                touchClone.remove();
                touchClone = null;
            }
            
            if (touchElement) {
                touchElement.style.opacity = '1';
            }
            
            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over');
            });
            
            if (dropZone && touchElement) {
                const targetBucket = dropZone.dataset.bucket;
                
                if (touchElement.classList.contains('distraction-item')) {
                    const distractionId = parseInt(touchElement.dataset.distractionId);
                    const distraction = state.distractions.find(d => d.id === distractionId);
                    
                    if (distraction) {
                        const newTask = {
                            id: Date.now() + Math.random(),
                            text: distraction.text,
                            bucket: targetBucket,
                            sprints: targetBucket === 'holding' ? 0 : (TASK_WEIGHTS[targetBucket] || 1),
                            priority: 'medium',
                            completed: false,
                            createdAt: new Date().toISOString()
                        };
                        
                        state.tasks[targetBucket].push(newTask);
                        state.distractions = state.distractions.filter(d => d.id !== distractionId);
                        state.intentions = state.intentions.filter(i => i.distractionId !== distractionId);
                        
                        saveState();
                        renderTasks();
                        renderDistractions();
                        initTouchDragDrop();
                    }
                } else if (touchElement.classList.contains('task-item')) {
                    const taskId = parseFloat(touchElement.dataset.taskId);
                    const fromBucket = touchElement.dataset.bucket;
                    
                    if (fromBucket !== targetBucket) {
                        moveTask(taskId, fromBucket, targetBucket);
                        initTouchDragDrop();
                    }
                }
            }
            
            touchElement = null;
            isDraggingTouch = false;
        }
        
        // ============================================
        // MOBILE BOTTOM SHEET ACTION MENU
        // ============================================
        
        let currentActionTask = null;
        let currentActionBucket = null;
        
        function showMobileActionSheet(task, bucket) {
            const sheet = document.getElementById('mobileActionSheet');
            const taskName = document.getElementById('actionSheetTaskName');
            const sprintValue = document.getElementById('actionSheetSprintValue');
            const sprintSection = document.getElementById('sprintAdjustSection');
            
            currentActionTask = task;
            currentActionBucket = bucket;
            
            // Set task name in header
            taskName.textContent = task.text.length > 40 ? task.text.substring(0, 40) + '...' : task.text;
            
            // Hide sprint adjustment for holding area
            if (bucket === 'holding') {
                sprintSection.style.display = 'none';
            } else {
                sprintSection.style.display = 'block';
                sprintValue.textContent = task.sprints || 0;
            }
            
            // Highlight current bucket
            document.querySelectorAll('[data-action="move"]').forEach(btn => {
                if (btn.dataset.bucket === bucket) {
                    btn.classList.add('action-btn-active');
                } else {
                    btn.classList.remove('action-btn-active');
                }
            });
            
            // Highlight current priority
            document.querySelectorAll('[data-action="priority"]').forEach(btn => {
                if (btn.dataset.priority === (task.priority || 'medium')) {
                    btn.classList.add('action-btn-active');
                } else {
                    btn.classList.remove('action-btn-active');
                }
            });
            
            // Show sheet
            sheet.classList.remove('hidden');
            setTimeout(() => sheet.classList.add('active'), 10);
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }
        
        function hideMobileActionSheet() {
            const sheet = document.getElementById('mobileActionSheet');
            sheet.classList.remove('active');
            setTimeout(() => sheet.classList.add('hidden'), 300);
            
            currentActionTask = null;
            currentActionBucket = null;
            
            // Restore body scroll
            document.body.style.overflow = '';
        }
        
        function setupMobileActionSheet() {
            const sheet = document.getElementById('mobileActionSheet');
            const overlay = sheet.querySelector('.action-sheet-overlay');
            const cancel = document.getElementById('actionSheetCancel');
            
            // Close on overlay click
            overlay.addEventListener('click', hideMobileActionSheet);
            
            // Close on cancel
            cancel.addEventListener('click', hideMobileActionSheet);
            
            // Handle move actions
            document.querySelectorAll('[data-action="move"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetBucket = btn.dataset.bucket;
                    if (currentActionTask && currentActionBucket !== targetBucket) {
                        moveTask(currentActionTask.id, currentActionBucket, targetBucket);
                        hideMobileActionSheet();
                    }
                });
            });
            
            // Handle priority actions
            document.querySelectorAll('[data-action="priority"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const priority = btn.dataset.priority;
                    if (currentActionTask) {
                        currentActionTask.priority = priority;
                        saveState();
                        renderTasks();
                        
                        // Update visual feedback
                        document.querySelectorAll('[data-action="priority"]').forEach(b => {
                            b.classList.remove('action-btn-active');
                        });
                        btn.classList.add('action-btn-active');
                    }
                });
            });
            
            // Handle sprint adjustments
            document.querySelectorAll('[data-action="sprint"]').forEach(btn => {
                btn.addEventListener('click', () => {
                    const delta = parseInt(btn.dataset.delta);
                    if (currentActionTask && currentActionBucket !== 'holding') {
                        currentActionTask.sprints = Math.max(0, (currentActionTask.sprints || 0) + delta);
                        document.getElementById('actionSheetSprintValue').textContent = currentActionTask.sprints;
                        saveState();
                        updateSprintTarget();
                        renderTasks();
                    }
                });
            });
            
            // Handle delete action
            document.querySelector('[data-action="delete"]').addEventListener('click', () => {
                if (currentActionTask && currentActionBucket) {
                    if (confirm('Delete this task?')) {
                        deleteTask(currentActionBucket, currentActionTask.id);
                        hideMobileActionSheet();
                    }
                }
            });
            
            // Swipe down to close
            let startY = 0;
            const content = sheet.querySelector('.action-sheet-content');
            
            content.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
            }, { passive: true });
            
            content.addEventListener('touchmove', (e) => {
                const currentY = e.touches[0].clientY;
                const diff = currentY - startY;
                
                if (diff > 0 && content.scrollTop === 0) {
                    // Scrolled to top and swiping down
                    if (diff > 100) {
                        hideMobileActionSheet();
                    }
                }
            }, { passive: true });
        }
        
        // Initialize on load
        setupMobileActionSheet();
        
        // Distraction action sheet - simplified for "convert to task"
        function showDistractionActionSheet(distraction) {
            const sheet = document.getElementById('mobileActionSheet');
            const taskName = document.getElementById('actionSheetTaskName');
            const sprintSection = document.getElementById('sprintAdjustSection');
            
            // Hide priority and sprint sections for distractions
            document.querySelectorAll('.action-section').forEach(section => {
                section.style.display = 'none';
            });
            
            // Only show move section
            document.querySelectorAll('[data-action="move"]').forEach(btn => {
                btn.parentElement.style.display = 'block';
                btn.classList.remove('action-btn-active');
            });
            
            taskName.textContent = 'Convert to Task: ' + (distraction.text.length > 30 ? distraction.text.substring(0, 30) + '...' : distraction.text);
            
            // Remove existing click handlers and add new ones
            const moveButtons = document.querySelectorAll('[data-action="move"]');
            moveButtons.forEach(btn => {
                const newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);
                
                newBtn.addEventListener('click', () => {
                    const targetBucket = newBtn.dataset.bucket;
                    
                    // Convert distraction to task
                    const newTask = {
                        id: Date.now() + Math.random(),
                        text: distraction.text,
                        bucket: targetBucket,
                        sprints: targetBucket === 'holding' ? 0 : (TASK_WEIGHTS[targetBucket] || 1),
                        priority: 'medium',
                        completed: false,
                        createdAt: new Date().toISOString()
                    };
                    
                    state.tasks[targetBucket].push(newTask);
                    state.distractions = state.distractions.filter(d => d.id !== distraction.id);
                    state.intentions = state.intentions.filter(i => i.distractionId !== distraction.id);
                    
                    saveState();
                    renderTasks();
                    renderDistractions();
                    hideMobileActionSheet();
                    
                    // Restore sections for next use
                    setTimeout(() => {
                        document.querySelectorAll('.action-section').forEach(section => {
                            section.style.display = 'block';
                        });
                    }, 300);
                });
            });
            
            // Show sheet
            sheet.classList.remove('hidden');
            setTimeout(() => sheet.classList.add('active'), 10);
            document.body.style.overflow = 'hidden';
        }
        
        // Update sprint target calculation
        function updateSprintTarget() {
            let totalTaskSprints = 0;
            
            // Priority multipliers
            const PRIORITY_MULTIPLIERS = {
                high: 1.5,
                medium: 1.0,
                low: 0.5
            };
            
            ['urgent', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    const baseSprints = task.sprints || 0;
                    const priority = task.priority || 'medium';
                    const multiplier = PRIORITY_MULTIPLIERS[priority] || 1.0;
                    
                    // Apply priority multiplier to sprint value
                    totalTaskSprints += baseSprints * multiplier;
                });
            });
            
            // Round to 1 decimal place for display
            state.plannedSprints = state.baselineSprints + Math.round(totalTaskSprints * 10) / 10;
            document.getElementById('sprintTarget').textContent = state.plannedSprints;
            saveState();
        }

        // Kept for compatibility - now uses sprint target
        function calculatePlannedSprints() {
            updateSprintTarget();
        }

        // ============================================
        // DISTRACTION MANAGEMENT
        // ============================================
        function addDistraction() {
            const input = document.getElementById('distractionInput');
            const text = input.value.trim();
            const isIntention = document.getElementById('intentionCheck').checked;
            
            if (!text) return;
            
            // Auto-expand card on first use
            autoExpandDistraction();
            
            const distraction = {
                id: Date.now(),
                text: text,
                timestamp: new Date().toISOString()
            };
            
            state.distractions.push(distraction);
            state.distractionCount++;
            
            if (isIntention) {
                state.intentions.push({
                    id: Date.now(),
                    distractionId: distraction.id,
                    text: text,
                    declared: new Date().toISOString(),
                    completed: false
                });
            }
            
            input.value = '';
            document.getElementById('intentionCheck').checked = false;
            
            saveState();
            renderDistractions();
            updateAgentMessage();
        }

        function removeDistraction(id) {
            state.distractions = state.distractions.filter(d => d.id !== id);
            
            // Check if this was an intention
            const intention = state.intentions.find(i => i.distractionId === id);
            if (intention) {
                intention.completed = true;
            }
            
            saveState();
            renderDistractions();
        }

        function renderDistractions() {
            const list = document.getElementById('distractionList');
            document.getElementById('distractionCount').textContent = state.distractions.length;
            
            list.innerHTML = '';
            state.distractions.forEach(d => {
                const isIntention = state.intentions.some(i => i.distractionId === d.id);
                
                const div = document.createElement('div');
                div.className = `distraction-item ${isIntention ? 'is-intention' : ''}`;
                div.draggable = true;
                div.dataset.distractionId = d.id;
                
                // Drag handle
                const dragHandle = document.createElement('span');
                dragHandle.className = 'task-drag-handle';
                dragHandle.textContent = '‚ãÆ‚ãÆ';
                
                // On mobile, clicking handle converts to task via bottom sheet
                dragHandle.addEventListener('click', (e) => {
                    if (window.innerWidth < 768) {
                        e.stopPropagation();
                        showDistractionActionSheet(d);
                    }
                });
                
                div.appendChild(dragHandle);
                
                // Intention badge
                if (isIntention) {
                    const badge = document.createElement('span');
                    badge.className = 'intention-badge';
                    badge.textContent = 'üí™';
                    div.appendChild(badge);
                }
                
                // Distraction text
                const textDiv = document.createElement('div');
                textDiv.className = 'distraction-text';
                textDiv.textContent = d.text;
                div.appendChild(textDiv);
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'distraction-delete';
                deleteBtn.textContent = '‚úï';
                deleteBtn.addEventListener('click', () => removeDistraction(d.id));
                div.appendChild(deleteBtn);
                
                // Drag events
                div.addEventListener('dragstart', (e) => {
                    draggedDistraction = d;
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                div.addEventListener('dragend', (e) => {
                    e.target.classList.remove('dragging');
                });
                
                list.appendChild(div);
            });
        }
        
        let draggedDistraction = null;

        // ============================================
        // AI AGENT
        // ============================================
        function generateAgentFeedback() {
            // Check time of day for late start feedback
            const currentHour = new Date().getHours();
            const config = loadModeConfig();
            const aiMessages = config.ai || state.aiMessages;
            
            if (!aiMessages) {
                updateAgentMessage();
                return;
            }
            
            const level = state.toughLoveLevel || 'balanced';
            const messages = aiMessages[level];
            
            let message = "";
            
            // Late start detection (after 11am)
            if (currentHour >= 11 && state.sprintCount === 0) {
                if (level === 'tough') {
                    message = "Starting at " + currentHour + ":00? The morning's gone. Better late than never, but this isn't optimal.";
                } else if (level === 'balanced') {
                    message = "Starting after 11am. Not ideal, but let's make the rest of the day count.";
                } else {
                    message = "Starting your day now. That's okay - let's focus on what we can accomplish from here.";
                }
            }
            // Early/on-time start
            else if (currentHour < 11) {
                if (level === 'tough') {
                    message = messages.welcome || "Let's execute. No excuses.";
                } else if (level === 'balanced') {
                    message = messages.welcome || "Ready to execute. Let's go.";
                } else {
                    message = messages.welcome || "You've got this. Let's begin.";
                }
            }
            // Default
            else {
                message = messages.welcome || "Sprint started. Stay focused.";
            }
            
            document.getElementById('agentText').textContent = message;
        }
        
        function updateAgentMessage() {
            // Get AI messages from mode config
            const config = loadModeConfig();
            const aiMessages = config.ai || state.aiMessages;
            
            if (!aiMessages) {
                // Fallback to default if config not loaded
                document.getElementById('agentText').textContent = "Start your first sprint to get feedback.";
                return;
            }
            
            const level = state.toughLoveLevel || 'balanced';
            const messages = aiMessages[level];
            
            let message = messages.welcome || "Start your first sprint to get feedback.";
            
            // Calculate wins efficiency
            const completedTasks = state.tasks.wins || [];
            const tasksWithData = completedTasks.filter(t => t.actualSprints > 0 && t.estimatedSprints > 0);
            let avgEfficiency = 1;
            if (tasksWithData.length > 0) {
                avgEfficiency = tasksWithData.reduce((sum, t) => {
                    return sum + (t.estimatedSprints / t.actualSprints);
                }, 0) / tasksWithData.length;
            }
            const beatEstimateCount = tasksWithData.filter(t => t.actualSprints <= t.estimatedSprints).length;

            // Determine which message to show based on state
            if (state.sprintCount > 0) {
                // Reference wins in messages
                if (state.tasksCompleted > 0 && avgEfficiency >= 1.2) {
                    // Crushing estimates
                    const crushingMessages = {
                        tough: [
                            `${state.tasksCompleted} wins, beating estimates. This is what execution looks like. Keep going.`,
                            `${beatEstimateCount} tasks finished early. You're outpacing your own predictions. Don't slow down.`,
                            `Efficiency above 120%. You're not lucky - you're executing. This is the standard now.`
                        ],
                        balanced: [
                            `${state.tasksCompleted} tasks done, ${beatEstimateCount} ahead of schedule. Strong work.`,
                            `${beatEstimateCount} tasks beat their estimates. You're getting faster.`,
                            `${state.tasksCompleted} wins with ${Math.round(avgEfficiency * 100)}% efficiency. Solid execution.`
                        ],
                        gentle: [
                            `Great progress! ${state.tasksCompleted} completed, and you're finishing faster than expected.`,
                            `You're crushing your estimates! ${beatEstimateCount} tasks done early. Amazing work.`,
                            `${state.tasksCompleted} tasks complete, and you're ahead of pace. Keep it up!`
                        ]
                    };
                    const messages = crushingMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                    
                } else if (state.sprintCount >= state.plannedSprints) {
                    // Met or exceeded target
                    const targetMetMessages = {
                        tough: [
                            `Sprint target hit. ${state.tasksCompleted > 0 ? state.tasksCompleted + ' wins logged.' : ''} What's next?`,
                            `Target met. Don't coast on today's wins. Tomorrow demands the same.`,
                            `${state.sprintCount} sprints done. Target cleared. Now finish what's open or call it.`
                        ],
                        balanced: [
                            `Sprint target achieved! ${state.tasksCompleted > 0 ? state.tasksCompleted + ' tasks completed.' : ''} Nice work.`,
                            `You hit your ${state.plannedSprints} sprint goal. Well executed.`,
                            `${state.sprintCount}/${state.plannedSprints} sprints complete. Target reached.`
                        ],
                        gentle: [
                            `You did it! Sprint target reached. ${state.tasksCompleted > 0 ? state.tasksCompleted + ' wins!' : ''} Great job today.`,
                            `Target achieved with ${state.sprintCount} sprints. You should feel proud.`,
                            `${state.plannedSprints} sprints complete! That's a productive day.`
                        ]
                    };
                    const messages = targetMetMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                    
                } else if (state.tasksCompleted > 3 && state.sprintCount < state.plannedSprints * 0.7) {
                    // Solid wins but behind sprint target
                    const behindButProgressMessages = {
                        tough: [
                            `${state.tasksCompleted} wins is good, but you're ${state.plannedSprints - state.sprintCount} sprints behind target. Close the gap.`,
                            `Tasks are getting done but you're behind pace. ${state.plannedSprints - state.sprintCount} sprints left. Execute.`,
                            `${state.tasksCompleted} wins won't matter if you miss your sprint target. Focus.`
                        ],
                        balanced: [
                            `${state.tasksCompleted} tasks completed. Keep pushing to hit your sprint target.`,
                            `Good progress on tasks, but ${state.plannedSprints - state.sprintCount} sprints behind goal. Let's finish strong.`,
                            `${state.tasksCompleted} wins so far. Need ${state.plannedSprints - state.sprintCount} more sprints to hit target.`
                        ],
                        gentle: [
                            `${state.tasksCompleted} tasks done - nice! ${state.plannedSprints - state.sprintCount} more sprints to reach your goal.`,
                            `You're making progress! ${state.tasksCompleted} complete. Keep going to hit your target.`,
                            `${state.tasksCompleted} wins today. You're doing well - just need a few more sprints.`
                        ]
                    };
                    const messages = behindButProgressMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                    
                } else if (state.distractionCount > 5) {
                    // Too many distractions
                    const distractionMessages = {
                        tough: [
                            `${state.distractionCount} distractions. They're parked, not gone. Either focus or quit lying to yourself.`,
                            `${state.distractionCount} logged distractions. Parking doesn't solve them. Execute or they win.`,
                            `${state.distractionCount} distractions today. That's a focus problem, not a productivity problem.`
                        ],
                        balanced: [
                            `${state.distractionCount} distractions logged. Time to park them and refocus.`,
                            `You've logged ${state.distractionCount} distractions. Let's get back to deep work.`,
                            `${state.distractionCount} distractions today. Ready to minimize them and execute?`
                        ],
                        gentle: [
                            `${state.distractionCount} distractions - it happens. Let's refocus and finish strong.`,
                            `I see ${state.distractionCount} distractions today. You're doing great by logging them. Let's focus now.`,
                            `${state.distractionCount} logged. Great job tracking them. Time to lock in.`
                        ]
                    };
                    const messages = distractionMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                    
                } else if (state.sprintCount < state.plannedSprints * 0.5) {
                    // Behind pace (less than 50% of target)
                    const behindPaceMessages = {
                        tough: [
                            `${state.sprintCount}/${state.plannedSprints} sprints. Less than halfway. Excuses don't show up in results.`,
                            `Behind pace. ${state.plannedSprints - state.sprintCount} sprints needed. Either commit or call it a day.`,
                            `You're at ${Math.round((state.sprintCount / state.plannedSprints) * 100)}% of target. That's not acceptable if you planned it.`
                        ],
                        balanced: [
                            `${state.sprintCount}/${state.plannedSprints} sprints done. Time to pick up the pace.`,
                            `You're behind target. ${state.plannedSprints - state.sprintCount} sprints to go. Let's make them count.`,
                            `Halfway point approaching. Need to accelerate to hit your ${state.plannedSprints} sprint goal.`
                        ],
                        gentle: [
                            `${state.sprintCount}/${state.plannedSprints} sprints so far. You've got time to reach your goal.`,
                            `You're making progress. ${state.plannedSprints - state.sprintCount} more sprints will get you there.`,
                            `Keep going! ${state.sprintCount} sprints done, more to come.`
                        ]
                    };
                    const messages = behindPaceMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                    
                } else {
                    // Making progress
                    const progressMessages = {
                        tough: [
                            `${state.tasksCompleted > 0 ? state.tasksCompleted + ' wins so far.' : state.sprintCount + ' sprints logged.'} Keep executing.`,
                            `Progress is being made. Don't let up now.`,
                            `${state.sprintCount}/${state.plannedSprints}. On pace. Finish it.`
                        ],
                        balanced: [
                            `${state.tasksCompleted > 0 ? state.tasksCompleted + ' wins so far.' : ''} Sprint target met. Well done.`,
                            `${state.sprintCount} sprints complete. You're making good progress.`,
                            `Solid execution today. ${state.tasksCompleted > 0 ? state.tasksCompleted + ' tasks done.' : 'Keep it up.'}`
                        ],
                        gentle: [
                            `${state.tasksCompleted > 0 ? state.tasksCompleted + ' wins! ' : ''}You're doing great. Keep going!`,
                            `${state.sprintCount} sprints done. You should feel good about this progress.`,
                            `Nice work today! ${state.tasksCompleted > 0 ? state.tasksCompleted + ' completed.' : 'Keep it up!'}`
                        ]
                    };
                    const messages = progressMessages[level];
                    message = messages[Math.floor(Math.random() * messages.length)];
                }
            }

            document.getElementById('agentText').textContent = message;
        }

        // ============================================
        // PROACTIVE AI COACH SYSTEM
        // ============================================
        
        let aiCoachState = {
            lastActivityTime: Date.now(),
            lastMessageTime: Date.now(),
            messageInterval: null,
            idleWarningShown: false,
            taskEstimateWarningShown: {}
        };
        
        function startProactiveAICoach() {
            // Check every 60 seconds for proactive messages
            if (aiCoachState.messageInterval) {
                clearInterval(aiCoachState.messageInterval);
            }
            
            aiCoachState.messageInterval = setInterval(() => {
                checkForProactiveMessages();
            }, 60000); // Check every minute
            
            console.log('ü§ñ Proactive AI Coach started');
        }
        
        function trackUserActivity() {
            aiCoachState.lastActivityTime = Date.now();
            aiCoachState.idleWarningShown = false;
        }
        
        function checkForProactiveMessages() {
            const now = Date.now();
            const idleTime = (now - aiCoachState.lastActivityTime) / 1000 / 60; // minutes
            const timeSinceLastMessage = (now - aiCoachState.lastMessageTime) / 1000 / 60;
            
            // Don't spam messages - wait at least 5 minutes between proactive messages
            if (timeSinceLastMessage < 5) return;
            
            const level = state.toughLoveLevel || 'balanced';
            let message = null;
            
            // 1. IDLE DETECTION (15+ minutes of inactivity)
            if (idleTime >= 15 && !aiCoachState.idleWarningShown && !state.timer.isRunning) {
                if (level === 'tough') {
                    message = `${Math.floor(idleTime)} minutes idle. Momentum dies in stillness. Start a sprint or pack it in.`;
                } else if (level === 'balanced') {
                    message = `You've been idle for ${Math.floor(idleTime)} minutes. Time to get back in the game?`;
                } else {
                    message = `Taking a break? You've been away for ${Math.floor(idleTime)} minutes. Ready to start when you are.`;
                }
                aiCoachState.idleWarningShown = true;
            }
            
            // 2. TASK OVERRUN DETECTION (task taking more sprints than estimated)
            else if (state.currentSprintTask) {
                const task = findTaskById(state.currentSprintTask);
                if (task && task.actualSprints > task.estimatedSprints && task.estimatedSprints > 0) {
                    const overrun = task.actualSprints - task.estimatedSprints;
                    const taskKey = task.id + '-overrun';
                    
                    if (!aiCoachState.taskEstimateWarningShown[taskKey]) {
                        if (level === 'tough') {
                            message = `"${task.text}" is ${overrun} sprints over estimate. Your planning sucks. Learn or keep bleeding time.`;
                        } else if (level === 'balanced') {
                            message = `"${task.text}" is taking longer than expected (${overrun} extra sprints). Consider breaking it down next time.`;
                        } else {
                            message = `"${task.text}" needs more time than we thought. That's okay - estimates get better with practice.`;
                        }
                        aiCoachState.taskEstimateWarningShown[taskKey] = true;
                    }
                }
            }
            
            // 3. NO TASKS IN DEEPWORK (but has tasks in holding/urgent)
            else if (state.tasks.deepwork.length === 0 && 
                     (state.tasks.holding.length > 0 || state.tasks.urgent.length > 0) &&
                     !state.timer.isRunning) {
                if (level === 'tough') {
                    message = "Deepwork bucket is empty. You can't execute on vapor. Move tasks or admit you're not working.";
                } else if (level === 'balanced') {
                    message = "No tasks in Deepwork. Drag something from Holding to start executing.";
                } else {
                    message = "Your Deepwork queue is empty. Try moving a task there to get started.";
                }
            }
            
            // 4. BEHIND PACE (past noon, less than 50% of target)
            else if (!state.timer.isRunning) {
                const currentHour = new Date().getHours();
                if (currentHour >= 12 && state.sprintCount < state.plannedSprints * 0.5) {
                    const deficit = state.plannedSprints - state.sprintCount;
                    if (level === 'tough') {
                        message = `It's past noon. You're ${deficit} sprints behind. Clock's ticking and excuses don't count as work.`;
                    } else if (level === 'balanced') {
                        message = `Afternoon check: You're ${deficit} sprints behind target. Time to pick up the pace.`;
                    } else {
                        message = `You're ${deficit} sprints away from your goal. You've got this - let's make it happen.`;
                    }
                }
            }
            
            // 5. DISTRACTION CREEP (3+ distractions without sprint in last 30 min)
            else if (state.distractionCount >= 3 && !state.timer.isRunning) {
                if (level === 'tough') {
                    message = `${state.distractionCount} distractions logged. Parking them doesn't remove them. Execute or they win.`;
                } else if (level === 'balanced') {
                    message = `${state.distractionCount} distractions today. Ready to park them and focus?`;
                } else {
                    message = `I see ${state.distractionCount} distractions. Great job logging them. Let's tackle some real work now.`;
                }
            }
            
            // 6. LONG TIMER RUNNING (60+ minutes on single sprint - something's wrong)
            else if (state.timer.isRunning && state.timer.timerType === 'focus') {
                const timerRuntime = (Date.now() - (state.timer.endTime - (state.timer.duration * 1000))) / 1000 / 60;
                if (timerRuntime >= 60) {
                    if (level === 'tough') {
                        message = "Timer's been running an hour. Either finish the sprint or admit you're not working.";
                    } else if (level === 'balanced') {
                        message = "This sprint has been running for over an hour. Everything okay? Consider resetting.";
                    } else {
                        message = "Your timer's been going a while. Take a break if you need to - it's important to rest.";
                    }
                }
            }
            
            // 7. FIRST SPRINT ENCOURAGEMENT (0 sprints, tasks in deepwork, afternoon)
            else if (state.sprintCount === 0 && state.tasks.deepwork.length > 0) {
                const currentHour = new Date().getHours();
                if (currentHour >= 10 && currentHour < 17) {
                    if (level === 'tough') {
                        message = "Zero sprints. Tasks are sitting there. Start isn't perfect - it's just necessary. Click a duration.";
                    } else if (level === 'balanced') {
                        message = "Ready to start your first sprint? You've got tasks queued up - let's go.";
                    } else {
                        message = "Whenever you're ready, your first sprint is waiting. You've got this!";
                    }
                }
            }
            
            if (message) {
                updateProactiveMessage(message);
                aiCoachState.lastMessageTime = now;
            }
        }
        
        function updateProactiveMessage(message) {
            const agentText = document.getElementById('agentText');
            if (agentText) {
                agentText.textContent = message;
                
                // Brief highlight animation
                agentText.style.transition = 'background-color 0.3s';
                agentText.style.backgroundColor = 'rgba(245, 91, 7, 0.1)';
                setTimeout(() => {
                    agentText.style.backgroundColor = '';
                }, 2000);
            }
        }
        
        function findTaskById(taskId) {
            for (const bucket of Object.keys(state.tasks)) {
                const task = state.tasks[bucket].find(t => t.id === taskId);
                if (task) return task;
            }
            return null;
        }

        // ============================================
        // GRADING
        // ============================================
        function calculateGrade() {
            const sprintScore = Math.min((state.sprintCount / state.plannedSprints) * 100, 100);
            const distractionPenalty = state.distractionCount * 5;
            const finalScore = Math.max(sprintScore - distractionPenalty, 0);
            
            if (finalScore >= 97) return 'A+';
            if (finalScore >= 93) return 'A';
            if (finalScore >= 90) return 'A-';
            if (finalScore >= 87) return 'B+';
            if (finalScore >= 83) return 'B';
            if (finalScore >= 80) return 'B-';
            if (finalScore >= 77) return 'C+';
            if (finalScore >= 73) return 'C';
            if (finalScore >= 70) return 'C-';
            if (finalScore >= 67) return 'D+';
            if (finalScore >= 63) return 'D';
            if (finalScore >= 60) return 'D-';
            return 'F';
        }

        function updateCurrentGrade() {
            const grade = calculateGrade();
            document.getElementById('currentGrade').textContent = grade;
        }

        // ============================================
        // END OF DAY
        // ============================================
        function showEndOfDayModal() {
            document.getElementById('eodSprints').textContent = state.sprintCount;
            document.getElementById('eodPlanned').textContent = state.plannedSprints;
            document.getElementById('eodTasks').textContent = state.tasksCompleted;
            document.getElementById('eodDistractions').textContent = state.distractionCount;
            
            const autoGrade = calculateGrade();
            document.getElementById('systemGrade').textContent = autoGrade;
            document.getElementById('userGrade').textContent = autoGrade;
            
            // Select the auto grade button
            document.querySelectorAll('.grade-btn').forEach(btn => {
                if (btn.dataset.grade === autoGrade) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
            
            document.getElementById('eodModal').classList.remove('hidden');
        }

        function completeDay() {
            const today = new Date().toDateString();
            const autoGrade = calculateGrade();
            const userGrade = document.getElementById('userGrade').textContent;
            const reflection = document.getElementById('reflectionInput').value;
            
            // Move all unfinished tasks to holding area for tomorrow
            ['urgent', 'deepwork', 'strategic'].forEach(bucket => {
                state.tasks[bucket].forEach(task => {
                    task.bucket = 'holding';
                    task.sprints = 0; // Reset sprint count
                    state.tasks.holding.push(task);
                });
                state.tasks[bucket] = []; // Clear the bucket
            });
            
            // Convert all distractions to tasks in holding area
            state.distractions.forEach(distraction => {
                const newTask = {
                    id: Date.now() + Math.random(),
                    text: distraction.text,
                    bucket: 'holding',
                    sprints: 0,
                    completed: false,
                    createdAt: new Date().toISOString()
                };
                state.tasks.holding.push(newTask);
            });
            
            // Save wins before clearing for subject tracking
            const winsToSave = [...state.tasks.wins];
            
            // Clear distractions and intentions
            state.distractions = [];
            state.intentions = [];
            
            // Clear today's wins for fresh start tomorrow
            state.tasks.wins = [];
            
            const report = {
                date: today,
                sprintCount: state.sprintCount,
                plannedSprints: state.plannedSprints,
                distractionCount: state.distractionCount,
                tasksCompleted: state.tasksCompleted,
                meetingMinutes: state.meetingMinutes,
                autoGrade: autoGrade,
                userGrade: userGrade,
                gradesMatch: autoGrade === userGrade,
                reflection: reflection,
                score: Math.min((state.sprintCount / state.plannedSprints) * 100, 100),
                timestamp: new Date().toISOString(),
                wins: winsToSave  // Include wins for subject breakdown
            };
            
            const history = JSON.parse(localStorage.getItem('focushub_history') || '[]');
            history.push(report);
            localStorage.setItem('focushub_history', JSON.stringify(history));
            
            // Track total sessions for feedback prompts
            const totalSessions = parseInt(localStorage.getItem('focushub_total_sessions') || '0') + 1;
            localStorage.setItem('focushub_total_sessions', totalSessions.toString());
            
            // Save state so tasks persist in holding for tomorrow
            saveState();
            
            localStorage.setItem('focushub_session_state', 'ended');
            
            // Check if should prompt for feedback
            checkEndOfDayFeedbackPrompt();
            
            window.location.href = 'overview.html';
        }

        // ============================================
        // RENDERING
        // ============================================
        function renderAll() {
            renderTasks();
            renderDistractions();
            updateCurrentGrade();
            
            // Initialize touch drag & drop for mobile
            if ('ontouchstart' in window) {
                initTouchDragDrop();
            }
            
            document.getElementById('sprintProgress').textContent = state.sprintCount;
            document.getElementById('sprintTarget').textContent = state.plannedSprints;
            document.getElementById('taskProgress').textContent = state.tasksCompleted;
            document.getElementById('breaksProgress').textContent = state.breaksCount;
            document.getElementById('distractionProgress').textContent = state.distractionCount;
            
            // Sync energy dropdown state
            const energySelect = document.getElementById('energySelect');
            if (energySelect) {
                energySelect.value = state.energyLevel;
            }
            
            // Set recommended timer button
            const recommendedDuration = ENERGY_DURATIONS[state.energyLevel];
            document.querySelectorAll('.duration-btn').forEach(btn => {
                if (parseInt(btn.dataset.duration) === recommendedDuration) {
                    btn.classList.add('recommended');
                } else {
                    btn.classList.remove('recommended');
                }
            });

            // Sync tough love dropdown
            const toughLoveSelect = document.getElementById('toughLoveSelect');
            if (toughLoveSelect) {
                toughLoveSelect.value = state.toughLoveLevel;
            }
        }

        // ============================================
        // BREAK BUTTON - POMODORO RULES
        // ============================================
        function updateBreakButton() {
            const breakBtn = document.getElementById('breakBtn');
            if (!breakBtn) return;
            
            // Pomodoro rule: Long break after every 4 sprints
            if (state.sprintCount > 0 && state.sprintCount % 4 === 0) {
                breakBtn.setAttribute('data-duration', '15');
                breakBtn.textContent = 'Long Break (15 min)';
            } else {
                breakBtn.setAttribute('data-duration', '5');
                breakBtn.textContent = 'Break (5 min)';
            }
        }
        
        // ============================================
        // COLLAPSIBLE CARDS
        // ============================================
        function toggleCard(cardType) {
            let content, toggle;
            
            if (cardType === 'distraction') {
                content = document.getElementById('distractionContent');
                toggle = document.getElementById('distractionToggle');
            } else if (cardType === 'grade') {
                content = document.getElementById('gradeContent');
                toggle = document.getElementById('gradeToggle');
            }
            
            if (!content || !toggle) return;
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñ∂';
            }
        }
        
        // Auto-expand distraction card on first use
        function autoExpandDistraction() {
            const content = document.getElementById('distractionContent');
            const toggle = document.getElementById('distractionToggle');
            if (content && toggle && content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñº';
            }
        }
        
        // ============================================
        // DAILY FIRST-RUN PROMPT
        // ============================================
        function checkDailyFirstRun() {
            const today = new Date().toDateString();
            const lastPrompt = localStorage.getItem('focushub_last_daily_prompt');
            
            // If this is a new day and no timer running
            if (lastPrompt !== today && !state.timer.isRunning) {
                // Scroll to task section
                setTimeout(() => {
                    const taskSection = document.querySelector('.task-manager');
                    if (taskSection) {
                        taskSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        
                        // Highlight task input briefly
                        const taskInput = document.getElementById('taskInput');
                        if (taskInput) {
                            taskInput.style.border = '2px solid var(--industrial-orange)';
                            taskInput.focus();
                            setTimeout(() => {
                                taskInput.style.border = '';
                            }, 3000);
                        }
                    }
                }, 500);
                
                // Mark prompt as shown
                localStorage.setItem('focushub_last_daily_prompt', today);
            }
        }

        // ============================================
        // THEME TOGGLE
        // ============================================
        const themeToggle = document.getElementById('themeToggle');
        const appLogo = document.getElementById('appLogo');
        
        function initTheme() {
            const savedTheme = localStorage.getItem('focushub_theme') || 'dark';
            setTheme(savedTheme);
        }
        
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('focushub_theme', theme);
            
            const appLogo = document.getElementById('appLogo');
            const startDayLogo = document.getElementById('startDayLogo');
            
            // Update toggle button and logos
            if (theme === 'dark') {
                themeToggle.textContent = 'üåô Dark';
                if (appLogo) appLogo.src = 'FocusHub_horiinv.svg'; // White text for dark theme
                if (startDayLogo) startDayLogo.src = 'FocusHub_vertdark.svg';
            } else {
                themeToggle.textContent = '‚òÄÔ∏è Light';
                if (appLogo) appLogo.src = 'FocusHub_horinorm.svg'; // Orange text for light theme
                if (startDayLogo) startDayLogo.src = 'FocusHub_vertnorm.svg';
            }
        }
        
        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme') || 'light';
            const newTheme = current === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        }
        
        themeToggle.addEventListener('click', toggleTheme);
        initTheme();

        // ============================================
        // HEADER SCROLL & TIMER
        // ============================================
        const appHeader = document.querySelector('.app-header');
        const headerTimer = document.getElementById('headerTimer');
        
        window.addEventListener('scroll', () => {
            if (window.scrollY > 100) {
                appHeader.classList.add('scrolled');
                updateHeaderTimer();
            } else {
                appHeader.classList.remove('scrolled');
            }
        });
        
        function updateHeaderTimer() {
            if (state.timer.isRunning) {
                const minutes = Math.floor(state.timer.timeLeft / 60);
                const seconds = state.timer.timeLeft % 60;
                headerTimer.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            } else {
                headerTimer.textContent = '';
            }
        }

        // ============================================
        // MORNING REFLECTION
        // ============================================
        const morningModal = document.getElementById('morningModal');
        const closeMorningBtn = document.getElementById('closeMorningBtn');
        const generateReflection = document.getElementById('generateReflection');
        const reflectionContent = document.getElementById('reflectionContent');
        
        const reflections = [
            {
                text: "The day stretches before you like an empty canvas. What you choose to place on it reflects not just your plans, but your character. Discipline is not a burden placed upon you by others‚Äîit is the gift you give to your future self. Today, you have the power to honor your commitments or to excuse your failures. Choose deliberately.",
                attribution: "On Discipline and Duty"
            },
            {
                text: "You will be tempted to drift. Your attention will be pulled in a dozen directions. This is not a moral failing‚Äîthis is the nature of the mind. But you are not merely your impulses. You possess the capacity to redirect, to refocus, to persist. Use it. The scattered mind achieves nothing. The focused mind moves mountains.",
                attribution: "On Focus and Perseverance"
            },
            {
                text: "Today, you will face resistance. The voice that says 'later' or 'not now' or 'this doesn't matter.' That voice is not wisdom. It is entropy. Progress requires you to act against comfort, against ease, against the path of least resistance. This is not punishment. This is the price of growth.",
                attribution: "On Resistance and Growth"
            },
            {
                text: "You are not here to feel productive. You are here to produce. Feelings follow action, not the other way around. Start before you feel ready. Work before you feel motivated. The path forward is not paved with perfect conditions‚Äîit is built by imperfect effort, repeated daily.",
                attribution: "On Action Over Feeling"
            },
            {
                text: "Each task before you is an opportunity to practice integrity. Not the integrity of grand gestures, but the integrity of small promises kept. When you say you will do something, and then you do it, you build trust with yourself. This is the foundation of all achievement.",
                attribution: "On Integrity and Trust"
            },
            {
                text: "The work you avoid today does not disappear‚Äîit compounds. Every delay adds weight to tomorrow's burden. But the inverse is also true: every task completed today lightens tomorrow's load. You control which future you create. Choose wisely.",
                attribution: "On Time and Consequence"
            },
            {
                text: "Excellence is not a destination. It is a practice. Today, you will not achieve perfection. You will achieve effort. String enough days of effort together, and you will look back surprised at what you have built. But first, you must begin.",
                attribution: "On Excellence Through Practice"
            },
            {
                text: "Your energy is finite. Your attention is finite. Every distraction is not merely a loss of time‚Äîit is a theft of potential. Guard your focus as you would guard your most valuable possession. Because it is.",
                attribution: "On Stewardship of Attention"
            },
            {
                text: "Today, you may fail. You may fall short of your target, succumb to distraction, or lose focus. This does not make you a failure. It makes you human. What matters is not perfection, but the choice to return tomorrow. Persistence outlasts talent.",
                attribution: "On Failure and Persistence"
            },
            {
                text: "The tasks before you are not obstacles to your life. They are your life. This moment, this work, this effort‚Äîthis is not the preamble to something greater. This is it. Be here. Do this. Make it count.",
                attribution: "On Presence and Purpose"
            }
        ];
        
        function showMorningReflection() {
            // Check if already shown today
            const today = new Date().toDateString();
            const lastShown = localStorage.getItem('focushub_morning_reflection_date');
            
            if (lastShown === today) {
                return; // Already shown today
            }
            
            // Load or generate reflection
            loadReflection();
            morningModal.classList.remove('hidden');
        }
        
        async function loadReflection() {
            // Use smart selection from appropriate tradition
            const reflection = await getSmartReflectionByTradition();
            
            reflectionContent.innerHTML = `
                <p class="reflection-headline" style="font-family: 'Courier New', monospace; font-size: 0.75rem; font-weight: 700; color: var(--industrial-orange); letter-spacing: 1.5px; margin-bottom: 1rem; text-align: center;">${reflection.headline}</p>
                <p class="reflection-text" style="font-size: 1.125rem; line-height: 1.8; color: var(--text-primary); font-weight: 400; font-style: italic;">${reflection.text}</p>
            `;
        }
        
        async function generateNewReflection() {
            // Use smart selection from appropriate tradition
            const reflection = await getSmartReflectionByTradition();
            
            reflectionContent.innerHTML = `
                <p class="reflection-headline" style="font-family: 'Courier New', monospace; font-size: 0.75rem; font-weight: 700; color: var(--industrial-orange); letter-spacing: 1.5px; margin-bottom: 1rem; text-align: center;">${reflection.headline}</p>
                <p class="reflection-text" style="font-size: 1.125rem; line-height: 1.8; color: var(--text-primary); font-weight: 400; font-style: italic;">${reflection.text}</p>
            `;
        }
        
        async function getSmartReflectionByTradition() {
            // Get user's selected tradition  
            let tradition = 'universal';
            try {
                const hasPremium = await isPremiumUser();
                if (hasPremium) {
                    tradition = await getReflectionTradition();
                }
            } catch (error) {
                console.log('Using default universal reflections');
            }
            
            // Select appropriate reflection set
            let reflectionSet = EXPANDED_REFLECTIONS; // Default universal
            
            switch(tradition) {
                case 'catholic':
                    if (typeof REFLECTIONS_CATHOLIC !== 'undefined') {
                        reflectionSet = REFLECTIONS_CATHOLIC;
                    }
                    break;
                case 'christian':
                    if (typeof REFLECTIONS_CHRISTIAN !== 'undefined') {
                        reflectionSet = REFLECTIONS_CHRISTIAN;
                    }
                    break;
                case 'jewish':
                    if (typeof REFLECTIONS_JEWISH !== 'undefined') {
                        reflectionSet = REFLECTIONS_JEWISH;
                    }
                    break;
                case 'islamic':
                    if (typeof REFLECTIONS_ISLAMIC !== 'undefined') {
                        reflectionSet = REFLECTIONS_ISLAMIC;
                    }
                    break;
                case 'hindu':
                    if (typeof REFLECTIONS_HINDU !== 'undefined') {
                        reflectionSet = REFLECTIONS_HINDU;
                    }
                    break;
                case 'buddhist':
                    if (typeof REFLECTIONS_BUDDHIST !== 'undefined') {
                        reflectionSet = REFLECTIONS_BUDDHIST;
                    }
                    break;
            }
            
            // Use existing smart selection algorithm
            return getSmartReflectionFromSet(reflectionSet);
        }
        
        function getSmartReflectionFromSet(reflectionSet) {
            // Get today's context
            const now = new Date();
            const dayOfWeek = now.getDay();
            const hour = now.getHours();
            
            // Get user's recent patterns
            const lastEnergy = localStorage.getItem('focushub_energy') || 'medium';
            const streak = parseInt(localStorage.getItem('focushub_streak') || '0');
            
            // Get reflection history
            const history = JSON.parse(localStorage.getItem('focushub_reflection_history') || '[]');
            const recentThemes = history.slice(-7).map(h => h.theme);
            const recentIds = history.slice(-10).map(h => h.id);
            
            // Filter out recently seen
            const available = reflectionSet.filter(r => !recentIds.includes(r.id));
            
            if (available.length < 5) {
                localStorage.setItem('focushub_reflection_history', JSON.stringify([]));
                return reflectionSet[Math.floor(Math.random() * reflectionSet.length)];
            }
            
            // Score each reflection
            const scored = available.map(reflection => {
                let score = 0;
                if (dayOfWeek === 1 && reflection.tags.includes('monday')) score += 5;
                if (dayOfWeek === 5 && reflection.tags.includes('friday')) score += 3;
                if (hour < 11 && reflection.tags.includes('morning')) score += 3;
                if (streak === 0 && reflection.tags.includes('fresh-start')) score += 4;
                if (streak >= 7 && reflection.tags.includes('long-streak')) score += 4;
                if (lastEnergy === 'low' && reflection.tags.includes('low-energy')) score += 3;
                if (recentThemes.includes(reflection.theme)) score -= 2;
                if (reflection.tags.includes('any-day')) score += 0.5;
                return { ...reflection, score };
            });
            
            scored.sort((a, b) => b.score - a.score);
            const topCandidates = scored.slice(0, 5);
            const selected = topCandidates[Math.floor(Math.random() * topCandidates.length)];
            
            // Record selection
            history.push({ id: selected.id, theme: selected.theme, date: new Date().toDateString() });
            localStorage.setItem('focushub_reflection_history', JSON.stringify(history.slice(-30)));
            
            return selected;
        }
        
        function closeMorningReflection() {
            morningModal.classList.add('hidden');
            const today = new Date().toDateString();
            localStorage.setItem('focushub_morning_reflection_date', today);
        }
        
        closeMorningBtn.addEventListener('click', closeMorningReflection);
        generateReflection.addEventListener('click', generateNewReflection);
        
        // Show morning reflection after day starts (if not shown today)
        setTimeout(() => {
            if (state.sessionState !== 'not_started') {
                showMorningReflection();
            }
        }, 1000);
        
        // ============================================
        // SPRINT COMPLETION CELEBRATION
        // ============================================
        
        function showCompletionCelebration() {
            // Create celebration overlay
            const celebration = document.createElement('div');
            celebration.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                z-index: 10000;
                pointer-events: none;
            `;
            
            // Create checkbox element
            const checkbox = document.createElement('div');
            checkbox.style.cssText = `
                width: 120px;
                height: 120px;
                background: #000000;
                border: 4px solid #f45b07;
                border-radius: 8px;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 8px 24px rgba(245, 91, 7, 0.4);
            `;
            checkbox.innerHTML = '<span style="font-size: 72px; color: white;">‚úì</span>';
            
            // Create pulse ring
            const pulse = document.createElement('div');
            pulse.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 120px;
                height: 120px;
                border: 3px solid #f45b07;
                border-radius: 8px;
                opacity: 0.8;
                animation: celebrationPulse 0.6s ease-out;
            `;
            
            celebration.appendChild(pulse);
            celebration.appendChild(checkbox);
            document.body.appendChild(celebration);
            
            // Fade out after 300ms
            setTimeout(() => {
                celebration.style.transition = 'opacity 0.3s ease-out';
                celebration.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(celebration);
                }, 300);
            }, 300);
        }
        
        // Add CSS animation for pulse
        if (!document.getElementById('celebrationStyles')) {
            const style = document.createElement('style');
            style.id = 'celebrationStyles';
            style.textContent = `
                @keyframes celebrationPulse {
                    0% {
                        transform: translate(-50%, -50%) scale(1);
                        opacity: 0.8;
                    }
                    100% {
                        transform: translate(-50%, -50%) scale(1.8);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        // ============================================
        // FIRST-RUN EXPERIENCE
        // ============================================
        
        function checkFirstRunState() {
            const firstSessionComplete = localStorage.getItem('focushub_first_session_complete');
            
            if (!firstSessionComplete) {
                showFirstRunHelpers();
            }
        }
        
        function showFirstRunHelpers() {
            // Show timer helper (near start session control)
            const timerHelper = document.getElementById('firstRunTimerHelper');
            if (timerHelper) {
                timerHelper.style.display = 'block';
            }
            
            // Show task helper only if no tasks exist
            if (state.tasks.length === 0) {
                const taskHelper = document.getElementById('firstRunTaskHelper');
                if (taskHelper) {
                    taskHelper.style.display = 'block';
                }
            }
        }
        
        function hideFirstRunHelpers() {
            const timerHelper = document.getElementById('firstRunTimerHelper');
            const taskHelper = document.getElementById('firstRunTaskHelper');
            
            if (timerHelper) {
                timerHelper.style.display = 'none';
            }
            if (taskHelper) {
                taskHelper.style.display = 'none';
            }
        }
        
        // Initialize the app (handled by checkAuthAndInit() in auth section)
    </script>

<script>
// ============================================
// BETA FEEDBACK SYSTEM
// ============================================
let currentFeedbackType = 'bug';

function openFeedbackModal() {
    document.getElementById('feedbackModal').classList.remove('hidden');
    document.getElementById('feedbackText').focus();
}

function closeFeedbackModal() {
    document.getElementById('feedbackModal').classList.add('hidden');
    // Reset form
    document.getElementById('feedbackText').value = '';
    document.getElementById('feedbackEmail').value = '';
    // Reset type selection
    document.querySelectorAll('.feedback-type-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('.feedback-type-btn[data-type="bug"]').classList.add('active');
    currentFeedbackType = 'bug';
}

// Feedback type selection
document.querySelectorAll('.feedback-type-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.feedback-type-btn').forEach(b => {
            b.classList.remove('active');
            b.style.background = 'var(--bg-secondary)';
            b.style.borderColor = 'var(--border-light)';
            b.style.color = 'var(--text-primary)';
        });
        btn.classList.add('active');
        btn.style.background = 'var(--industrial-orange)';
        btn.style.borderColor = 'var(--industrial-orange)';
        btn.style.color = 'white';
        currentFeedbackType = btn.dataset.type;
    });
});

// Submit feedback
async function submitFeedback() {
    const text = document.getElementById('feedbackText').value.trim();
    const email = document.getElementById('feedbackEmail').value.trim();
    const submitBtn = document.getElementById('feedbackSubmitBtn');
    
    if (!text) {
        alert('Please tell us what\'s on your mind!');
        return;
    }
    
    // Disable button
    submitBtn.disabled = true;
    submitBtn.textContent = 'Sending...';
    
    // Collect feedback data
    const feedbackData = {
        type: currentFeedbackType,
        text: text,
        email: email || 'anonymous',
        page: document.title,
        timestamp: new Date().toISOString(),
        browser: navigator.userAgent,
        screenSize: `${window.innerWidth}x${window.innerHeight}`,
        userId: window.currentFirebaseUser ? window.currentFirebaseUser.email : 'not-logged-in',
        sessionCount: state.sprintCount || 0
    };
    
    try {
        // Send to your email via FormSubmit.co
        const response = await fetch('https://formsubmit.co/ajax/watersjb@gmail.com', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({
                _subject: `FocusHub BETA: ${currentFeedbackType}`,
                _template: 'table',
                Type: currentFeedbackType,
                Feedback: text,
                Email: email || 'No email provided',
                Page: feedbackData.page,
                Timestamp: feedbackData.timestamp,
                Browser: feedbackData.browser,
                Screen: feedbackData.screenSize,
                UserID: feedbackData.userId,
                SessionCount: feedbackData.sessionCount
            })
        });
        
        if (response.ok) {
            // Success!
            submitBtn.textContent = '‚úì Sent!';
            submitBtn.style.background = 'var(--success)';
            
            setTimeout(() => {
                closeFeedbackModal();
                submitBtn.disabled = false;
                submitBtn.textContent = 'Send Feedback';
                submitBtn.style.background = '';
            }, 2000);
        } else {
            throw new Error('Failed to send');
        }
        
    } catch (error) {
        console.error('Feedback submission error:', error);
        
        // Fallback: Save to localStorage
        const savedFeedback = JSON.parse(localStorage.getItem('focushub_feedback') || '[]');
        savedFeedback.push(feedbackData);
        localStorage.setItem('focushub_feedback', JSON.stringify(savedFeedback));
        
        alert('Feedback saved locally! We\'ll collect it when you\'re back online.');
        
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Feedback';
        closeFeedbackModal();
    }
}

// Close modal on Escape key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        const feedbackModal = document.getElementById('feedbackModal');
        if (feedbackModal && !feedbackModal.classList.contains('hidden')) {
            closeFeedbackModal();
        }
    }
});

// End-of-day feedback prompt (after 3 sessions)
function checkEndOfDayFeedbackPrompt() {
    const totalSessions = parseInt(localStorage.getItem('focushub_total_sessions') || '0');
    const hasPrompted = localStorage.getItem('focushub_eod_feedback_prompted');
    
    // After 3 days of use, prompt once
    if (totalSessions >= 3 && !hasPrompted) {
        setTimeout(() => {
            if (confirm('Quick feedback on FocusHub? (Takes 30 seconds)')) {
                openFeedbackModal();
            }
            localStorage.setItem('focushub_eod_feedback_prompted', 'true');
        }, 1000);
    }
}

// ============================================
// BACKGROUND TIMER PERSISTENCE
// ============================================
// Handle tab/app switching to keep timer accurate
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Tab hidden - save current state
        if (window.state && window.state.timer.isRunning) {
            const timerState = {
                timeLeft: window.state.timer.timeLeft,
                duration: window.state.timer.duration,
                isRunning: window.state.timer.isRunning,
                timerType: window.state.timer.timerType,
                lastUpdated: Date.now()
            };
            localStorage.setItem('focushub_timer', JSON.stringify(timerState));
            console.log('üåô Timer saved (tab hidden)');
        }
    } else {
        // Tab visible again - restore and adjust timer
        if (window.state && window.state.timer.isRunning) {
            const savedTimer = localStorage.getItem('focushub_timer');
            if (savedTimer) {
                const timerData = JSON.parse(savedTimer);
                const elapsed = Math.floor((Date.now() - timerData.lastUpdated) / 1000);
                const adjustedTimeLeft = Math.max(0, timerData.timeLeft - elapsed);
                
                if (adjustedTimeLeft > 0) {
                    window.state.timer.timeLeft = adjustedTimeLeft;
                    console.log(`üîÑ Timer adjusted: -${elapsed}s (${adjustedTimeLeft}s remaining)`);
                } else {
                    // Timer expired while away
                    console.log('‚úÖ Timer completed while tab was hidden');
                    clearInterval(window.state.timer.interval);
                    if (typeof completeTimer === 'function') {
                        completeTimer();
                    }
                }
            }
        }
    }
});

// Save timer state periodically even when tab is active
setInterval(() => {
    if (window.state && window.state.timer.isRunning) {
        const timerState = {
            timeLeft: window.state.timer.timeLeft,
            duration: window.state.timer.duration,
            isRunning: window.state.timer.isRunning,
            timerType: window.state.timer.timerType,
            lastUpdated: Date.now()
        };
        localStorage.setItem('focushub_timer', JSON.stringify(timerState));
    }
}, 2000); // Save every 2 seconds
</script>

<!-- Privacy & Data Management Footer -->
<footer style="
    margin-top: 4rem;
    padding: 2rem;
    border-top: 1px solid var(--border-light);
    text-align: center;
    color: var(--text-secondary);
    font-size: 0.875rem;
">
    <div style="margin-bottom: 1rem;">
        <a href="/privacy.html" style="color: var(--accent-blue); margin: 0 1rem;">Privacy Policy</a>
        <span style="color: var(--border-light);">|</span>
        <button onclick="exportAllUserData()" style="
            background: none;
            border: none;
            color: var(--accent-blue);
            cursor: pointer;
            font-size: 0.875rem;
            margin: 0 1rem;
            text-decoration: underline;
        ">Export My Data</button>
        <span style="color: var(--border-light);">|</span>
        <button onclick="deleteAllUserData()" style="
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 0.875rem;
            margin: 0 1rem;
            text-decoration: underline;
        ">Delete My Account</button>
    </div>
    <p style="margin: 0.5rem 0;">
        üîí Your tasks are automatically deleted every Friday<br>
        Data stored locally & optionally synced (encrypted)
    </p>
    <p style="margin: 0.5rem 0; font-size: 0.75rem;">
        &copy; 2026 FocusHub. Built for privacy.
    </p>
</footer>

</body>
</html>
